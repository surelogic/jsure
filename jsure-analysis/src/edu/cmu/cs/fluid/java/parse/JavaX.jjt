// $Header: /cvs/fluid/fluid/src/edu/cmu/cs/fluid/java/parse/JavaX.jjt,v 1.62 2007/07/19 16:53:34 aarong Exp $
/**
%- Copyright
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */
/*
 * Author: Edwin Chan
 * Modified: 2/15/99
 *
 * Author John Boyland
 * Modified 2004
 * TODO:
 *   <type>.class syntax (not quite parsed right even now for name.class) (Done 2005?)
 *   Java 5 extensions:
 *     method/constructor type formals
%- Options
 */
options {
  JAVA_UNICODE_ESCAPE = true;
  MULTI = false;
  NODE_DEFAULT_VOID=true;
  NODE_FACTORY=true;
  // DEBUG_PARSER=true;
  // COMMON_TOKEN_ACTION=true;
  NODE_SCOPE_HOOK=true;
  JDK_VERSION = "1.5";
}

/*
%- Parser code
*/
PARSER_BEGIN(JavaParser)

package edu.cmu.cs.fluid.java.parse;

import edu.cmu.cs.fluid.FluidError;
import edu.cmu.cs.fluid.ir.IRNode;
import edu.cmu.cs.fluid.java.JavaNode;
import edu.cmu.cs.fluid.java.JavaOperator;
import edu.cmu.cs.fluid.java.operator.*;
import edu.cmu.cs.fluid.java.promise.*;
import edu.cmu.cs.fluid.parse.JJNode;
import edu.cmu.cs.fluid.parse.Node;
import edu.cmu.cs.fluid.parse.ParseException;
import edu.cmu.cs.fluid.parse.Token;
import edu.cmu.cs.fluid.tree.Operator;

@SuppressWarnings("all")
public class JavaParser {

  public static void main(String args[]) {
    Runtime r = Runtime.getRuntime();
    System.out.println("\nInitial footprint : "+r.totalMemory()+" bytes");
    long startTime = System.currentTimeMillis();
    JavaNode n = parse(args);

    long parseTime = System.currentTimeMillis();
    System.out.println("\nAfter parsing:      "+r.totalMemory()+" bytes");
    JavaNode.dumpTree(System.out, n, 1);

    long endTime = System.currentTimeMillis();
    System.out.println("\nFinal footprint :   "+r.totalMemory()+" bytes");
    printDiff("\nElapsed parse time: ", startTime, parseTime);
    printDiff("\nElapsed print time: ", parseTime, endTime);
  }
  public static void printDiff(String s, long start, long end) {
    long time = end - start;
    long mins = time / (60 * 1000);
    long msecs = time % (60 * 1000);

    System.out.println(s+mins+":"+(msecs/1000.0));
  }

  public static JavaNode parse(String args[]) {
    JavaParser parser;
    if (args.length == 0) {
      System.out.println("Java Parser:  Reading from standard input . . .");
      parser = new JavaParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Java Parser:  Reading from file " + args[0] + " . . .");
      try {
        parser = new JavaParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Java Parser:  File " + args[0] + " not found.");
        return null;
      }
    } else { 
      System.out.println("Java Parser:  Usage is one of:");
      System.out.println("         java JavaParser < inputfile");
      System.out.println("OR");
      System.out.println("         java JavaParser inputfile");
      return null;
    }
    try {
      JavaNode n = parser.Start();
//      System.out.println("Thank you.");
      return n;	
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
    return null;
  }

  public static final boolean isAtEOF() {
    boolean flag;

    try {
      flag = testEOF();
    } catch (ParseException e) {
      flag = false;
    }

    return flag;
  }

  static String test = null;

  static void jjtreeOpenNodeScope(Node node) {
    JavaNode n = (JavaNode) node;
    Token t = getToken(1);
    
    Token comment = t.specialToken;
    if (comment == null || comment.marked) return;

    String s = gatherUpComments(comment); // go back 
    s = gatherUpMatchingComments(comment, s); // go forward
    
    // System.out.println(n+" got "+s);    
    JavaNode.setComment(n, s);
  }

  static void jjtreeCloseNodeScope(Node node) {
    // getToken(0);
  }

  static String gatherUpComments(Token t) {
    if (t == null) return null;

    Token last = t.specialToken;
    String s   = gatherUpComments(last);
    if (t.marked) return s;

    t.marked = true;
    return (s == null) ? t.image : (s + t.image);
  }

  static String gatherUpMatchingComments(Token t, String s) {
    if (t.next != null) {
      Token next = t.next;
      if (next.marked) return s;

      // FIX check if consecutive?
      if (t.beginColumn == next.beginColumn) {
	next.marked = true;
	s += next.image;
	return gatherUpMatchingComments(next, s);
      }
    }
    return s;
  }

  public static final void FieldDeclaration() throws ParseException
  {
    FieldDeclaration(JavaNode.ALL_FALSE);
  }
  
  public static final void MethodDeclaration() throws ParseException
  {
    MethodDeclaration(JavaNode.ALL_FALSE);
  }
}

PARSER_END(JavaParser)
/*
%- Token definitions
*/


TOKEN_MGR_DECLS : 
{
  static void CommonTokenAction(Token t) {
    if (t.specialToken == null) return;

    printComments(t.specialToken);
    System.out.println("before "+t.beginLine + ":" + t.beginColumn + "-" + 
		       t.endLine + ":" + t.endColumn + " " + t.image);
  }

  static void printComments(Token t) {
    if (t == null) return;

    Token last = t.specialToken;
    printComments(last);

    Token match = matchColumn(last, t.beginLine, t.beginColumn);
    if (match != null) {
      if (match == last) {
        System.out.print("Matched ");
      } else {
        System.out.println("Matches "+match.image);
      }
    }
    System.out.println(t.beginLine + ":" + t.beginColumn + "-" + 
	  	       t.endLine + ":" + t.endColumn + " " + t.image);
  }

  static Token matchColumn(Token t, int line, int col) {
    if (t == null) return null;

    if (t.beginLine < line && t.beginColumn == col) {
      return t;
    }
    return matchColumn(t.specialToken, line, col);
  }
}

/*
%-- Skip
*/
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/*
%-- Special: comments
*/
// 1st hack (obsolete now with tags in specific places)
// SKIP: { <ANNOTATION: "//@"> } 

SPECIAL_TOKEN : /* COMMENTS */
{
 <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| <FORMAL_COMMENT:    "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/**
 * Summary comment (possibly with in-line tags or HTML).
 * Other comments
      In-line code
      ...
 * Series of @ tags
*/

/*
%-- Reserved words
*/

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/*
%-- Literals
*/
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}
/*
%-- Identifiers
*/
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
/*
%-- Separators
*/
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/*
%-- Operators
*/
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
%-* THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

JavaNode Start() : {}
{
  CompilationUnit() <EOF>
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode StartExpr() : {}
{
  Expression() <EOF>
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode StartStmt() : {}
{
  Statement() <EOF>
  { return (JavaNode)jjtree.rootNode(); }
}

boolean testEOF() : {}
{
  (<EOF> { return true; })
  | ({} { return false; })
}

/*
 * Annotation modifiers
 */
void annotation() : {}
{
  LOOKAHEAD(4)
  ("@" Identifier(jjtThis) "(" elementValue() ")" ) #SingleElementAnnotation(1)
|
  LOOKAHEAD(3)
  ("@" Identifier(jjtThis) "(" annotationElementPairs() ")" ) #NormalAnnotation(1)
|
  "@" Identifier(jjtThis) #MarkerAnnotation(0)
}

void annotations() #Annotations : {}
{
  ( annotation() ) *
}

void annotationElementPairs() #ElementValuePairs : {}
{
  annotationElementPair() ( "," annotationElementPair() ) *
}

void annotationElementPair() #ElementValuePair(1) : {}
{
  Identifier(jjtThis) "=" elementValue()
}

void elementValue() : {}
{
  Expression()
| elementValueArrayInitializer()
| annotation()
}

void elementValueArrayInitializer() #ElementValueArrayInitializer : {}
{
  "{" [ elementValue() ( LOOKAHEAD(2) "," elementValue() )* ] [ "," ] "}"
}

/*
%-- Done - Modifiers
*/

void typeModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  ( 
    "abstract"	{ JavaNode.setModifier(n, JavaNode.ABSTRACT, true); } 
  | "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "final"	{ JavaNode.setModifier(n, JavaNode.FINAL, true); } 
  | "strictfp" { JavaNode.setModifier(n,JavaNode.STRICTFP,true); }
  )*
}

void nestedTypeModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  ( 
    "static"	{ JavaNode.setModifier(n, JavaNode.STATIC, true); } 
  | "abstract"	{ JavaNode.setModifier(n, JavaNode.ABSTRACT, true); } 
  | "final"	{ JavaNode.setModifier(n, JavaNode.FINAL, true); } 
  | "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  | "strictfp" { JavaNode.setModifier(n,JavaNode.STRICTFP,true); }
  )* 
}
/* FIX? 
	also is this right for interfaces?
*/

void accessModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  [
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  ]
}

void constrModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  (
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  | "native"	{ JavaNode.setModifier(n, JavaNode.NATIVE, true); } 
  | "strictfp" { JavaNode.setModifier(n,JavaNode.STRICTFP,true); }
  )*
}

void methodModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  ( 
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  | "static"	{ JavaNode.setModifier(n, JavaNode.STATIC, true); } 
  | "abstract"	{ JavaNode.setModifier(n, JavaNode.ABSTRACT, true); } 
  | "final"	{ JavaNode.setModifier(n, JavaNode.FINAL, true); } 
  | "native"	{ JavaNode.setModifier(n, JavaNode.NATIVE, true); } 
  | "synchronized" { JavaNode.setModifier(n, JavaNode.SYNCHRONIZED, true); } 
  | "strictfp" { JavaNode.setModifier(n,JavaNode.STRICTFP,true); }
  )* 
}

void interfaceModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  ( 
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "abstract"	{ JavaNode.setModifier(n, JavaNode.ABSTRACT, true); } 
  )*
}

void setImplicit(JavaNode n) : {}
{
  { JavaNode.setImplicit(n); }
}

/*
%-- Done
*/
void CompilationUnit() #CompilationUnit(3) : {}
{
  PackageDeclaration() 
  ( ImportDeclaration() )* #ImportDeclarations(true)
  ( TypeDeclaration() )*   #TypeDeclarations
}

void PackageDeclaration() : {}
{
  LOOKAHEAD(1)
  annotations()
  <PACKAGE> PackageName(jjtThis) #NamedPackageDeclaration(1) ";"
  | {}		         #UnnamedPackageDeclaration(0)
}

void ImportDeclaration() #ImportDeclaration(1) : {}
{
  <IMPORT> 
  ( LOOKAHEAD( PackageName(null) ";" )
    DeclaredTypeName()		
  | (PackageName(jjtThis) "." "*")	#DemandName(0) 
  )
  ";"
}

/*
%-- Done
*/
void TypeDeclaration() : {}
{
  // FIX
  LOOKAHEAD( typeModifiers(null) <CLASS> )
  ClassDeclaration() 
|
  InterfaceDeclaration()
|
  ";"
}

/*
 * Declaration syntax follows.
 */

void ClassDeclaration() #ClassDeclaration() : {}
{
  annotations()
  typeModifiers(jjtThis) 
  UnmodifiedClassDeclaration(jjtThis)
}

void UnmodifiedClassDeclaration(JavaNode n) : {Token t;}
{
  {
    IRNode init = InitDeclaration.getInitMethod(n);
    ReceiverDeclaration.getReceiverNode(init);
    ClassInitDeclaration.getClassInitMethod(n);
  }
  <CLASS> (t=<STRING_LITERAL> { n.setInfo(t.image.substring(1,t.image.length()-1).intern()); } | Identifier(n) )
  TypeFormals() optExtension() optImplements() 
  ClassBody()
}

void TypeFormals() #TypeFormals : {}
{
  ("<" TypeFormal() ("," TypeFormal()) * ">" ) ?
}

void TypeFormal() #TypeFormal(1) : {}
{
  // modifiers?
  Identifier(jjtThis)
  MoreBounds()
}

// we used to distinguish the first bound from remaining bounds, hence the name "MoreBounds".
void MoreBounds() #MoreBounds : {}
{
  optExtension()
  ("&" GeneralClassType())*
}

/* 
%-- Done - Extension/Implements
*/
void optExtension() : {}
{
  <EXTENDS> GeneralClassType()
| 
  ( 
    { jjtThis.setInfo("java.lang.Object");  }
    setImplicit(jjtThis)
  ) #NamedType(0)
}

void optImplements() #Implements : {}
{
  (<IMPLEMENTS> DeclaredTypeNameList() )?
}

/*
%-- Done
*/
void ClassBody() #ClassBody : {}
{
  "{" ( [ "//@" ] ClassBodyDeclaration())* 
  "}"
}

void NestedClassDeclaration() #NestedClassDeclaration() : {}
{
  annotations()
  nestedTypeModifiers(jjtThis)
  UnmodifiedClassDeclaration(jjtThis)
  [ LOOKAHEAD(2) ";"]
}

void ClassBodyDeclaration() : {}
{
  LOOKAHEAD(2)
  Initializer()
|
  LOOKAHEAD( nestedTypeModifiers(null) <CLASS> )
  NestedClassDeclaration()
|
  LOOKAHEAD( nestedTypeModifiers(null) <INTERFACE> )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( constrModifiers(null) Identifier(null) "(" )
  ConstructorDeclaration()
|
  LOOKAHEAD( methodModifiers(null) ("<" | ResultType() Identifier(null) "(" ))
  MethodDeclaration(JavaNode.ALL_FALSE)
|
  FieldDeclaration(JavaNode.ALL_FALSE)
|
  ";"
}

void InterfaceDeclaration() #InterfaceDeclaration() : {}
{
  annotations()
  interfaceModifiers(jjtThis)
  UnmodifiedInterfaceDeclaration(jjtThis)
}

void NestedInterfaceDeclaration() #NestedInterfaceDeclaration() : {}
{
  annotations()
  nestedTypeModifiers(jjtThis)
  UnmodifiedInterfaceDeclaration(jjtThis)
}

void UnmodifiedInterfaceDeclaration(JavaNode n) : {}
{
  { 
    ClassInitDeclaration.getClassInitMethod(n);
  }
  <INTERFACE> Identifier(n) TypeFormals() optExtensions()
  "{" ( InterfaceMemberDeclaration() )* #ClassBody "}"
}

/*
%-- Done - Extensions
*/
void optExtensions() #Extensions : {}
{
  (<EXTENDS> DeclaredTypeNameList() )?
}

/*
%-- Done
*/
void InterfaceMemberDeclaration() :
{}
{
  LOOKAHEAD( nestedTypeModifiers(null) <CLASS> )
  NestedClassDeclaration()
|
  LOOKAHEAD( nestedTypeModifiers(null) <INTERFACE> )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( methodModifiers(null) ("<" | ResultType() Identifier(null) "(" ))
  // FIX need to specify that it should not be static, or final
  MethodDeclaration(JavaNode.PUBLIC | JavaNode.ABSTRACT)
|
  FieldDeclaration(JavaNode.PUBLIC | JavaNode.STATIC | JavaNode.FINAL)
}

/*
%-- Done - FieldModifiers
*/
void FieldDeclaration(int mods) #FieldDeclaration() : { JavaNode n; }
{
  annotations()
  { n = (JavaNode) jjtree.currentNode(); 
    n.setModifiers(mods);
  }
  ( 
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  | "static"	{ JavaNode.setModifier(n, JavaNode.STATIC, true); } 
  | "final"	    { JavaNode.setModifier(n, JavaNode.FINAL, true); } 
  | "transient"	{ JavaNode.setModifier(n, JavaNode.TRANSIENT, true); } 
  | "volatile"	{ JavaNode.setModifier(n, JavaNode.VOLATILE, true); } 
  )* 
  Type() 
  ( VariableDeclarator() ( "," VariableDeclarator() )* ) #VariableDeclarators
  ";"
}

/*
%-- Done
*/
void VariableDeclarator() #VariableDeclarator(1) : {}
{
  VariableDeclaratorId(jjtThis) 
  ( "=" VariableInitializer()	#Initialization(1)
  | {}			#NoInitialization(0)
  )
}

void VariableDeclaratorId(JavaNode n) : {Token t;}
{
  t=<STRING_LITERAL> { JJNode.setInfo(n,t.image.intern()); }
|
  Identifier(n) ArrayDims(n)
}

/* 
%-- Done - counting array dims (FIX gen node?)
*/
void ArrayDims1(JavaNode n) : { int count = 0; }
{
  ( LOOKAHEAD(2) "[" "]" { count++; } )+
  { JavaNode.setDimInfo(n, count); }
}

void ArrayDims(JavaNode n) : { int count = 0; }
{
  ( LOOKAHEAD(2) "[" "]" { count++; } )*
  { JavaNode.setDimInfo(n, count); }
}

/*
%-- Done - Initializer
*/
void VariableInitializer() : {}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() #ArrayInitializer : {}
{
  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"
}

void MethodDeclaration(int mods) #MethodDeclaration() : { JavaNode n; }
{
  annotations()
  { n = (JavaNode) jjtree.currentNode(); 
    n.setModifiers(mods);
    ReturnValueDeclaration.getReturnNode(n);
    if ((mods & JavaNode.STATIC) == 0) {
      ReceiverDeclaration.getReceiverNode(n);
    }
  }
  methodModifiers(jjtThis)
  TypeFormals()
  ResultType() MethodDeclarator(jjtThis) exceptions()
  ( Block() #MethodBody | ";" #NoMethodBody )
}

/* 1 node here */
void MethodDeclarator(JavaNode n) : {}
{
  Identifier(n) FormalParameters() ArrayDims(n)
}

void FormalParameters() #Parameters : {}
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter() #ParameterDeclaration() : { JavaNode n; }
{
  annotations()
  { n = (JavaNode) jjtree.currentNode(); 
    n.setModifiers(JavaNode.ALL_FALSE);
  }
  [ "final" 	{ JavaNode.setModifier(n, JavaNode.FINAL, true); } ] 
  Type() VariableDeclaratorId(jjtThis)
}

/*
%-- Done - Throws
*/
void exceptions() #Throws : {}
{
  (<THROWS> DeclaredTypeNameList() )?
}

/*
%-- Done - how to deal w/ constructor invocation
*/
void ConstructorDeclaration() #ConstructorDeclaration() : {}
{
  annotations()
  constrModifiers(jjtThis)
  {
    JavaNode n = jjtree.currentNode();
    ReceiverDeclaration.getReceiverNode(n);
  }
  TypeFormals()
  Identifier(jjtThis) FormalParameters() exceptions()
  ( ConstructorBody() | ";" #NoMethodBody )
}

void ConstructorBody() #MethodBody(1) : {}
{
  ( "{"
    ( LOOKAHEAD(ExplicitConstructorInvocation()) 
      ExplicitConstructorInvocation() ";"
      | ImplicitConstructorInvocation() 
    ) #ExprStatement(1)
    BlockStatements()
  "}" )
  #BlockStatement 
}

/*
 * JTB parsing notes:
 * Since JavaCC doesn't handle left recursion,
 * we have to parse things as a prefix followed by multiple
 * suffixes (suffices?) as required.  We only parse until we
 * get an explicit constructor invocation.  If we get an expression,
 * we try to parse a suffix which will force it to be a constructor
 * invocation.
 *
 * Starting in Java 1.2 and later, we have to  handle things like
 * <expression>.super(...)   (super call)
 *     (not for "this") calls.
 * Starting in JDK  1.5, we have:
 * <expression>. [type actuals] super(...)
 * [type actuals] this(...)
 *
 * So the invocation includes:
 * <sname> ".this" + suffix
 * <sname>".super" + suffix
 * <sname>".super(" args ")" 
 *  <sname>"(" args ")"  + suffix (have to restructure -- yuck -- see below)
 *   "this" "(" args ")"
 *  "super" "(" args ")"
 *   [type actuals] in front of each of the previous three things
 *  <sname> + suffix
 *  <new> + suffix
 * "this" | "super" + suffix
 */
void ExplicitConstructorInvocation() : {String methodName = "<unknown>"; }
{
  StructuredName()	(
      LOOKAHEAD("." "this")
      {} #NameType(1)
      "." "this" #QualifiedThisExpression(1)
      ExplicitConstructorInvocationSuffix()
    | LOOKAHEAD("." "super" "(")
      {} #NameExpression(1)
      "." "super" #SuperExpression(0)
      Arguments() #NonPolymorphicConstructorCall(2)
    | LOOKAHEAD("." "super")
      {} #NameType(1)
      "." "super" #QualifiedSuperExpression(1)
      ExplicitConstructorInvocationSuffix()
    | LOOKAHEAD("(")
      { // HACK to preserve mark
        JavaNode base = (JavaNode) jjtree.peekNode();
        Operator op   = JJNode.tree.getOperator(base);
        Node receiver;
        if (op instanceof SimpleName) {
          methodName= SimpleName.getId(base);
          receiver = new JJNode(ImplicitReceiver.prototype);
        } else if (op instanceof QualifiedName) {
          methodName = QualifiedName.getId(base);
          receiver = (Node)JJNode.tree.getChild(base,0);
          JJNode.tree.clearParent((IRNode)receiver);
        } else {
          throw new ParseException("Internal Error: Structured Name wasn't a name?");
        }
        jjtree.pushNode(receiver);
      }
      Arguments() #NonPolymorphicMethodCall(2)
      {
	    Node mc = jjtree.popNode(); 
	    jjtree.popNode();
	    JJNode.setInfo((IRNode)mc,methodName);
	    jjtree.pushNode(mc);
	  }
	  ExplicitConstructorInvocationSuffix()
    |
      {} #NameExpression(1)
      ExplicitConstructorInvocationSuffix()
    )
|
  "this"		   #ThisExpression(0)
  Arguments() #NonPolymorphicConstructorCall(2)
|
  "super"   #SuperExpression(0)
  Arguments() #NonPolymorphicConstructorCall(2) 
|
  "(" Expression() ")"	  #ParenExpression(1)
  ExplicitConstructorInvocationSuffix()
|
  AllocationExpression()
  ExplicitConstructorInvocationSuffix()
|
   TypeActuals() (
    LOOKAHEAD(<IDENTIFIER>)
    {} #ImplicitReceiver(0)
    (Identifier(jjtThis) Arguments()) #PolymorphicMethodCall(3)
    ExplicitConstructorInvocationSuffix()
  | "super" #SuperExpression(0)
    Arguments() #PolymorphicConstructorCall(3)
  | "this" #ThisExpression(0)
    Arguments() #PolymorphicConstructorCall(3)
  )
}

/*
 * The suffix will include 
 *  "." <name> "(" args ")" + suffix
 * ".super(" args ")"
 * (optionally) same for "this" (syntax error actually)
 * [type actuals] intervening in the previous cases
 * "." <name> + suffix
 * [<expression>] + suffix
 * "." new ... + suffix
 */
void ExplicitConstructorInvocationSuffix() : { }
{
(
  LOOKAHEAD("." "new")
  "." AllocationExpression()	#OuterObjectSpecifier(2)
  ExplicitConstructorInvocationSuffix()
|
  "[" Expression() "]" 	#ArrayRefExpression(2)
  ExplicitConstructorInvocationSuffix()
|
  LOOKAHEAD("." <IDENTIFIER> "(")
  "." (Identifier(jjtThis) Arguments()) #NonPolymorphicMethodCall(2)
  ExplicitConstructorInvocationSuffix()
|
  LOOKAHEAD("." "<")
  "." TypeActuals() 
  (
    LOOKAHEAD("super")
    "super" #SuperExpression(0)
    Arguments() #PolymorphicConstructorCall(3)
    {} #OuterObjectSpecifier(2)
  |
    (Identifier(jjtThis) Arguments()) #PolymorphicMethodCall(3)
    ExplicitConstructorInvocationSuffix()
  )
|
  LOOKAHEAD("." <IDENTIFIER>)
  "." Identifier(jjtThis) #FieldRef(1)
  ExplicitConstructorInvocationSuffix()
| 
  LOOKAHEAD("." "super" "(")
  "." "super" #SuperExpression(0)
  Arguments() #NonPolymorphicConstructorCall(2)
  {} #OuterObjectSpecifier(2)
 )
}

void ImplicitConstructorInvocation() #NonPolymorphicConstructorCall(2) : {}
{
  ImplicitSuper() ImplicitArguments()
  setImplicit(jjtThis)
}

void ImplicitSuper() #SuperExpression(0) : {}
{
   {}
}

void ImplicitArguments() #Arguments(0) : {}
{
  {}
}

/* 
%-- Done - static modifier on init blocks
*/
void Initializer() #ClassInitializer(1) : { JavaNode n; }
{
  { n = (JavaNode) jjtree.currentNode(); 
    n.setModifiers(JavaNode.ALL_FALSE);
  }
  [ "static"	{ JavaNode.setModifier(n, JavaNode.STATIC, true); } ]
  Block()
}


/*
%- Type, name and expression syntax follows.
 */
/*
%-- Done
*/
void Type() : {}
{
  ( PrimitiveType() | GeneralClassType())
  // HACK: sucks up the node generated above
  [ ( ArrayDims1(jjtThis) ) #ArrayType(1) ]
}

void NamedType() #NameType : {}
{
  StructuredName()
}

void GeneralClassType() : {}
{
  NamedType()
  ( LOOKAHEAD("<")
    TypeActuals() #ParameterizedType(2)
  |
    LOOKAHEAD(".")
    "." Identifier(jjtThis) #TypeRef(1)
  )*
}

void PrimitiveType() : {}
{
  <BOOLEAN> #BooleanType
|
  "char" #CharType
| 
  "byte" #ByteType
|
  "short" #ShortType
|
  <INT> #IntType
|
  "long" #LongType
|
  "float" #FloatType
|
  "double" #DoubleType
}

void ResultType() : {}
{
  <VOID> #VoidType
|
  Type()
}

void TypeActuals() #TypeActuals : {}
{
  "<" TypeOrWildcard() ("," TypeOrWildcard())* ">"
}

void TypeOrWildcard() : {}
{
  "?" ( "extends" GeneralClassType() #WildcardExtendsType(1)
         | "super" GeneralClassType() #WildcardSuperType(1)
         | {} #WildcardType(0))
|
  Type()         
}

/* 
%-- Done - Name(List)
*/

void StructuredName() : {}
{
  Identifier(jjtThis) #SimpleName(0)
  ( LOOKAHEAD(2) "."
    Identifier(jjtThis) #QualifiedName(1) )*
}

// Eliminating the redundant Name node
// void Name() #Name(0) : 
//
void Name(JavaNode n) : 
{ StringBuffer name;
  Token t;
}
{
  t=<IDENTIFIER>
  { name = new StringBuffer(t.image); 
  }
  ( LOOKAHEAD(2) "." 
    t=<IDENTIFIER>
    { name.append('.').append(t.image); }
  )*
  { n.setInfo(name.toString().intern()); }
}

/* Note:
   these 'AST' nodes need to be repackaged by the binding resolution 
// void PackageName() : {}
*/
void PackageName(JavaNode n) : {}
{
  Name(n)
}

void DeclaredTypeName() : {}
{
  GeneralClassType()
}

void DeclaredTypeNameList() : {}
{
  GeneralClassType() ( "," GeneralClassType() )*
}

/*
%- Expression syntax follows.
 */
/*
%-- Done
*/
void Expression() : {}
{
  LOOKAHEAD( PrimaryExpression() AssignmentOperator() )
  Assignment()
|
  ConditionalExpression()
}

/*
%-- Done - (A Op= B) -> op slot
*/
void Assignment() : { JavaNode n; }
{
  PrimaryExpression() 
  (
    // HACK: sucks up the Primary above
    LOOKAHEAD( "=" )
    "=" Expression() 				#AssignExpression(2) 
  |
    ( { n = (JavaNode) jjtree.currentNode(); }
    AssignmentOperator(n) Expression() )	#OpAssignExpression(2) 
  ) 
}

void AssignmentOperator(JavaNode n) : { JavaOperator op; }
{
(
  "="	{ op = null; } 
| "*="	{ op = MulExpression.prototype; }
| "/="	{ op = DivExpression.prototype; }
| "%="	{ op = RemExpression.prototype; }
| "+="	{ op = AddExpression.prototype; }
| "-="	{ op = SubExpression.prototype; }
| "<<="	 { op = LeftShiftExpression.prototype; }
| ">>="	 { op = RightShiftExpression.prototype; }
| ">>>=" { op = UnsignedRightShiftExpression.prototype; }
| "&="	{ op = AndExpression.prototype; }
| "^="	{ op = XorExpression.prototype; }
| "|="	{ op = OrExpression.prototype; }
)
  // { JavaNode.setOp((JavaNode)jjtree.currentNode(), op); }
  { JavaNode.setOp(n, op); }
}

/*
%-- Done.
*/
void ConditionalExpression() #ConditionalExpression(>1) :{}
{
  ConditionalOrExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConditionalOrExpression() #ConditionalOrExpression(>1) : {}
{
  ConditionalAndExpression() [ "||" ConditionalOrExpression() ]
}

void ConditionalAndExpression() #ConditionalAndExpression(>1) : {}
{
  InclusiveOrExpression() [ "&&" ConditionalAndExpression() ]
}

void InclusiveOrExpression() #OrExpression(>1) : {}
{
  ExclusiveOrExpression() [ "|" InclusiveOrExpression() ]
}

void ExclusiveOrExpression() #XorExpression(>1) : {}
{
  AndExpression() [ "^" ExclusiveOrExpression() ]
}

void AndExpression() #AndExpression(>1) : {}
{
  EqualityExpression() [ "&" AndExpression() ]
}

/*
%-- Done - expanded syntax
*/
void EqualityExpression() : {}
{
  InstanceOfExpression() 

  // HACK: using the (2) to grab the first operand
  (
    "=="  InstanceOfExpression() #EqExpression(2) 
  | 
    "!="  InstanceOfExpression() #NotEqExpression(2) 
  )*
}

void InstanceOfExpression() #InstanceOfExpression(>1) : {}
{
  RelationalExpression() [ "instanceof" Type() ]
}

void RelationalExpression() : {}
{
  ShiftExpression() 

  // HACK: using the (2) to grab the first operand
  ( 
    "<" ShiftExpression()	#LessThanExpression(2)
  |
    ">" ShiftExpression()	#GreaterThanExpression(2)
  |
    "<=" ShiftExpression() #LessThanEqualExpression(2)
  |
    ">=" ShiftExpression() #GreaterThanEqualExpression(2)
  )*
}

void ShiftExpression() : {}
{
  AdditiveExpression() 

  // HACK: using the (2) to grab the first operand
  // FIX! Check precedence of shift operators.
  [
    "<<" ShiftExpression()	#LeftShiftExpression(2)
  |
    ">>" ShiftExpression()	#RightShiftExpression(2)
  |
    ">>>" ShiftExpression()	#UnsignedRightShiftExpression(2)
  ]
}

void AdditiveExpression() : {}
{

  MultiplicativeExpression() 

  // HACK: using the (2) to grab the first operand
  (
    "+" MultiplicativeExpression() #AddExpression(2)
  |
    "-" MultiplicativeExpression() #SubExpression(2)
  )*

}

void MultiplicativeExpression() : {}
{
  UnaryExpression() 

  // HACK: using the (2) to grab the first operand
  (
    "*" UnaryExpression() #MulExpression(2)
  |
    "/" UnaryExpression() #DivExpression(2)
  |
    "%" UnaryExpression() #RemExpression(2)
  )*
}

void UnaryExpression() : {}
{
  "+" UnaryExpression() #PlusExpression(1)
| 
  "-" UnaryExpression() #MinusExpression(1)
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

/*
%-- Done - elim redundancy?
*/
void PreIncrementExpression() #PreIncrementExpression(1) : {}
{
  "++" PrimaryExpression()
}

void PreDecrementExpression() #PreDecrementExpression(1) : {}
{
  "--" PrimaryExpression()
}

/*
%-- Done - Complement/Not
*/
void UnaryExpressionNotPlusMinus() : {}
{
  "~" UnaryExpression() #ComplementExpression(1)
| 
  "!" UnaryExpression() #NotExpression(1)
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

/*
%-- Done.
*/
// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() : {}
{
  LOOKAHEAD(2)
  "(" PrimitiveType()
|
  LOOKAHEAD("(" Name(null) "[")
  "(" Name(null) "[" "]"
|
  "(" Name(null) ")" 
  ( "~" | "!" | "(" | Identifier(null) | "this" | "super" | "new" | Literal() )
}

/*
%-- Done - Postfix
*/
void PostfixExpression() : {}
{
  PrimaryExpression() 
  // HACK: using the (1) to grab the PrimaryExpression
  [ "++" #PostIncrementExpression(1)
  | "--" #PostDecrementExpression(1)
  ]
}

/*
%-- Done.
*/
void CastExpression() #CastExpression(2) : {}
{
  LOOKAHEAD("(" PrimitiveType())
  "(" Type() ")" UnaryExpression()
|
  LOOKAHEAD("(" GeneralClassType())
  "(" Type() ")" UnaryExpressionNotPlusMinus()
}

/* 
%-- Fixed
*/
void PrimaryExpression() : {}
{
// HACK: the Prefix will be popped by the Suffix
//	 to make it left-recursive
  PrimaryPrefix() 
  [ LOOKAHEAD(2) PrimarySuffix() ]
}

/*
 * JTB parsing notes:
 * Since JavaCC doesn't handle left recursion,
 * we have to parse things as a prefix followed by multiple
 * suffixes (suffices?).
 *
 * Starting in Java 1.2 and later, we have to  handle things like
 * <Type>.class (including primitive types, including void)
 * <Type>[].class (including primitives types, not including void)
 * <Type>.this (named types only, no <..>)
 * <Type>.super (ditto)
 * <expression>.super(...)   (super call) --- See ExplicitConstructorInvocation
 *     (not for "this") calls.
 * Starting in JDK  1.5, we have:
 * <expression>. [type actuals] super(...)  (see ExplicitConstructorInvocation)
 * [type actuals] this(...) (see ExplicitConstructorInvocation)
 * [type actuals] foo(...)
 *
 * So the primary prefix includes:
 *   <Type>".class" (including arrays and void) as type expressions
 *       (<Type> will just be using primitive types)
 *  <structuredname>"[]"* ".class"
 * <sname> ".this"
 * <sname>".super"
 * <sname>".super(" args ")"   (see ExplicitConstructorInvocation)
 *  <sname>"(" args ")"  (have to restructure -- yuck -- see below)
 *   "this" "(" args ")"  (see ExplicitConstructorInvocation)
 *  "super" "(" args ")" (see ExplicitConstructorInvocation)
 *   [type actuals] in front of each of the previous three things
 *  <sname> 
 *  <literals>
 *  <new>
 * "this" | "super"
 */
void PrimaryPrefix() : {String methodName = "<unknown>"; }
{
  Literal()
|
  StructuredName()	(
      LOOKAHEAD("." "class")
      "." #NameType(1)
      "class" #ClassExpression(1)
    | LOOKAHEAD("[" "]")
      {} #NameType(1)
      ArrayDims1(jjtThis) #ArrayType(1)
      "." "class" #ClassExpression(1)
    | LOOKAHEAD("." "this")
      "." #NameType(1)
      "this" #QualifiedThisExpression(1)
    | LOOKAHEAD("." "super")
      "." #NameType(1)
      "super" #QualifiedSuperExpression(1)
    | LOOKAHEAD("(")
      { // HACK to preserve mark
        JavaNode base = (JavaNode) jjtree.peekNode();
        Operator op   = JJNode.tree.getOperator(base);
        Node receiver;
        if (op instanceof SimpleName) {
          methodName= SimpleName.getId(base);
          receiver = new JJNode(ImplicitReceiver.prototype);
        } else if (op instanceof QualifiedName) {
          methodName = QualifiedName.getId(base);
          receiver = (Node)JJNode.tree.getChild(base,0);
          JJNode.tree.clearParent((IRNode)receiver);
          receiver = (Node)NameExpression.createNode((IRNode)receiver);
        } else {
          throw new ParseException("Internal Error: Structured Name wasn't a name?");
        }
        jjtree.pushNode(receiver);
      }
      Arguments() #NonPolymorphicMethodCall(2)
      {
	    Node mc = jjtree.popNode(); 
	    jjtree.popNode();
	    JJNode.setInfo((IRNode)mc,methodName);
	    jjtree.pushNode(mc);
	  }
    |
      {} #NameExpression(1)
    )
|
  "this"		   #ThisExpression(0)
|
  "super"   #SuperExpression(0)
|
  "(" Expression() ")"	  #ParenExpression(1)
|
  AllocationExpression()
|
  LOOKAHEAD(2)
  PrimitiveType() ArrayDims1(jjtThis) #ArrayType(1) 
  "." "class" #ClassExpression(1)
|
  PrimitiveType()
  "." "class" #ClassExpression(1)
|
  "void" #VoidType(0) "." "class" #ClassExpression(1)
|
  TypeActuals() #ImplicitReceiver(0)
  (Identifier(jjtThis) Arguments()) #PolymorphicMethodCall(3)
}

/*
 * The suffix will include 
 *  "." <name> "(" args ")"
 * ".super(" args ")" (see ExplicitConstructorInvocation)
 * (optionally) same for "this" (syntax error actually)
 * [type actuals] intervening in the previous cases
 * "." <name>
 * [<expression>]
 * "." new ...
 */
void PrimarySuffix() : { }
{
(
  "[" Expression() "]" 	#ArrayRefExpression(2)
|
  LOOKAHEAD("." <IDENTIFIER> "(")
  "." (Identifier(jjtThis) Arguments()) #NonPolymorphicMethodCall(2)
|
  LOOKAHEAD("." "<")
  "." TypeActuals() 
  (Identifier(jjtThis) Arguments()) #PolymorphicMethodCall(3)
|
  LOOKAHEAD("." <IDENTIFIER>)
  "." Identifier(jjtThis) #FieldRef(1)
|
  LOOKAHEAD("." "new")
  "." AllocationExpression() #OuterObjectSpecifier(2)
 )
   [ LOOKAHEAD(2) PrimarySuffix() ]
}

/* 
%-- Experimental primary
void XPrimaryExpression() : {}
{
  PrimLiteral()			// none
|
  XPrimaryPrefix()
}

void XPrimaryPrefix() : {}
{
  LOOKAHEAD( "(" Name(null) ")" )
  (
    "super" "." Identifier()	// Ref, Id
  |
    Name()			// Type, Ref, Id
  | 
    "(" Name() ")"		// FIX Type, Ref, Id
  )
  [ XPrimarySuffix() ]
|
  (
    "(" Expression() ")"	// Ref
  |
    RefLiteral() 
  |
    AllocationExpression() 
  |
    "this"			// Ref
  )
  [ RefPrimarySuffix() ]
}

void XPrimarySuffix() : {}
{
  LOOKAHEAD(2)
  (
    "." 
    ( 
      "this"			// Ref
    |
      <CLASS>			// Ref
    |
      AllocationExpression()	// Ref
    )
  |
    "[" Expression() "]"	// Ref
  |
    Arguments()			// Ref
  )
  [ RefPrimarySuffix() ]
|
  "." Identifier()		// Ref, Id, Type?
  [ XPrimarySuffix() ]
}

void RefPrimarySuffix() : {}
{
  LOOKAHEAD(2)  
  (
    "." AllocationExpression()	// Ref
  |
    "[" Expression() "]"	// Ref
  )
  [ RefPrimarySuffix() ]
|
  "." Identifier()		// Ref, Id, Type?
  [ XPrimarySuffix() ]
}
*/

/* 
%-- Unused 
void TypePrimarySuffix() : {}
{
  LOOKAHEAD(2)
  "." "this"			// Ref
|
  LOOKAHEAD(2)
  "." <CLASS>			// Ref
|
  LOOKAHEAD(2)
  "." AllocationExpression()	// Ref
|
  "." Identifier()		// Ref, Id, Type?
}

void IdPrimarySuffix() : {}
{
  Arguments()			// Ref 
}
*/

/*
%-- Done.
*/
void Literal() : {}
{
  PrimLiteral()
|
  RefLiteral()
}

void PrimLiteral() : {}
{
  Integer()
|
  FloatingPoint()
|
  Character()
|
  BooleanLiteral()
/*
  <INTEGER_LITERAL>
|
  <FLOATING_POINT_LITERAL>
|
  <CHARACTER_LITERAL>
|
  <STRING_LITERAL>
*/
} 

void RefLiteral() : {}
{
  NullLiteral()
|
  String()
}

void BooleanLiteral() : {}
{
  "true"  #TrueExpression
|
  "false" #FalseExpression
}

void NullLiteral() : {}
{
  "null" #NullLiteral
}

/*
%-- Done.
*/
void Integer() #IntLiteral : { Token t; }
{
  t=<INTEGER_LITERAL>
  { ((JavaNode)jjtree.currentNode()).setInfo(t.image.intern()); }
}

void FloatingPoint() #FloatLiteral : { Token t; }
{
  t=<FLOATING_POINT_LITERAL>
  { ((JavaNode)jjtree.currentNode()).setInfo(t.image.intern()); }
}

void Character() #CharLiteral : { Token t; }
{
  t=<CHARACTER_LITERAL>
  { ((JavaNode)jjtree.currentNode()).setInfo(t.image.intern()); }
}

void String() #StringLiteral : { Token t; }
{
  t=<STRING_LITERAL>
  { ((JavaNode)jjtree.currentNode()).setInfo(t.image.intern()); }
}

/*
%-- Done.
*/
void Arguments() #Arguments : {}
{
//  "(" [ ArgumentList() ] ")"
  "(" [ Expression() ( "," [ "//@" ] Expression() )* ] ")"
}

/*
%-- Unused
void ArgumentList() : {}
{
  Expression() ( "," Expression() )*
}
*/

/*
%-- Done.
*/
void AllocationExpression() : { JavaNode n; }
{
  LOOKAHEAD(2)
  ( "new" PrimitiveType() ArrayDimensions(jjtThis) OptArrayInitializer() )
  #ArrayCreationExpression(3)
|
  LOOKAHEAD( "new" GeneralClassType() "[" )
  ( <NEW> GeneralClassType() ArrayDimensions(jjtThis) OptArrayInitializer() )
  #ArrayCreationExpression(3)
|
  "new"
  (
    LOOKAHEAD("<")
    TypeActuals() GeneralClassType() Arguments()
    #PolymorphicNewExpression(3)
  |
    GeneralClassType() Arguments()
    #NonPolymorphicNewExpression(2)
  )
  ( ClassBody() 
    { n = (JavaNode) jjtree.currentNode(); 
      IRNode init = InitDeclaration.getInitMethod(n);
      ReceiverDeclaration.getReceiverNode(init);
    }  
    #AnonClassExpression(2) ) ?
}

void OptArrayInitializer() : {}
{
  ArrayInitializer() | {} #NoArrayInitializer(0)
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimensions(JavaNode n) : {}
{
  LOOKAHEAD( "[" "]" )
  ArrayDims1(n)                                 #DimExprs(0)
|
  ( LOOKAHEAD(2) "[" Expression() "]" )+ 	#DimExprs
  ArrayDims(n)
}


/*
%- Statement syntax follows.
 */
/*
%-- Done.
*/
void Statement() : {}
{
(
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression() #ExprStatement";"
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
|
  AssertStatement()
)
  { test = "foo";
  // System.out.println("Image = "+token.image);
  }
}

void LabeledStatement() #LabeledStatement(1) : {}
{
  Identifier(jjtThis) ":" Statement() 
}

void Block() #BlockStatement : {}
{
  "{"
    // Added for promises
    ( "//@" | BlockStatement() )*
    // BlockStatements() 
  "}"
}

void BlockStatements() : {}
{
  ( BlockStatement() )*
}

/*
%-- Done.
*/
void BlockStatement() : {}
{
  LOOKAHEAD([ "final" ] Type() Identifier(null))
  LocalVariableDeclaration() ";"
|
  Statement()
|
  // FIX no modifiers
  (UnmodifiedClassDeclaration(jjtThis)	#ClassDeclaration(4)) #TypeDeclarationStatement(1)
}

/* 
%-- Done - modifiers 
*/
void LocalVariableDeclaration() #DeclStatement(3) : { JavaNode n; }
{
  { n = (JavaNode) jjtree.currentNode(); 
    n.setModifiers(JavaNode.ALL_FALSE);
  }
  annotations()
  [ "final"	{ JavaNode.setModifier(n, JavaNode.FINAL, true); } ] 
  Type() 
  (VariableDeclarator() ( "," VariableDeclarator() )* ) #VariableDeclarators
}

/*
%-- Done.
*/
void EmptyStatement() #EmptyStatement(0) : {}
{
  ";"
}

void StatementExpression() : {}
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.
 */
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  LOOKAHEAD( PrimaryExpression() AssignmentOperator() )
  Assignment()
|
  PostfixExpression()
}

void SwitchStatement() #SwitchStatement(2) : {}
{
  "switch" "(" Expression() ")" "{"
    ( ( SwitchLabel() 
        ( BlockStatement() )* #SwitchStatements
      ) #SwitchElement
    )* #SwitchBlock
  "}"
}

void SwitchLabel() : {}
{
  ("case" Expression() ":")	#ConstantLabel
|
  "default" ":" 		#DefaultLabel
}

/*
New If operator
*/
void IfStatement() #IfStatement(3) : {}
{
  "if" "(" Expression() ")" Statement() OptElse()
}

void OptElse() : {}
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
  LOOKAHEAD(1) "else" Statement() #ElseClause(1)
  | {} #NoElseClause(0)
}

void WhileStatement() #WhileStatement(2) : {}
{
  "while" "(" Expression() ")" Statement()
}

void DoStatement() #DoStatement(2) : {}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

void ForStatement() #ForStatement(4) : {}
{
  "for" 
  "("
  ( ForInit() 	 | {} #StatementExpressionList(0) )
  ";" 
  ( Expression() | {} #TrueExpression )
  ";" 
  ( StatementExpressionList() | {} #StatementExpressionList(0) )
  ")" 
  Statement()
}

void ForInit() : {}
{
  LOOKAHEAD( [ "final" ] Type() Identifier(null) )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() #StatementExpressionList : {}
{
  StatementExpression() ( "," StatementExpression() )*
}

void BreakStatement() : {}
{
/* "break" [ Identifier() ] ";" */
  "break" 
( 
  Identifier(jjtThis) 	#LabeledBreakStatement(0)
| 
  {} 	#BreakStatement(0)
) 
  ";"
}

void ContinueStatement() : {}
{
/* "continue" [ Identifier() ] ";" */
  "continue" 
( 
  Identifier(jjtThis) 	#LabeledContinueStatement(0)
| 
  {} 	#ContinueStatement(0) 
) 
  ";"
}

void ReturnStatement() : {}
{
/* "return" [ Expression() ] ";" */
  "return" 
( 
  Expression() 	#ReturnStatement(1)
| 
  {} 	#VoidReturnStatement(0)
) 
  ";"
}

void ThrowStatement() #ThrowStatement(1) : {}
{
  "throw" Expression() ";"
}

void SynchronizedStatement() #SynchronizedStatement(2): {}
{
  "synchronized" "(" Expression() ")" Block()
}

void TryStatement() #TryStatement(3): {}
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 * FIX still needed?
 */
{
  "try" Block()
(
  {}		#CatchClauses(0)
  ( "finally" Block() ) #Finally(1)
|
  (( "catch" "(" FormalParameter() ")" Block() ) #CatchClause(2) 
  )+ 	#CatchClauses(true)
  ( 
    "finally" Block()	#Finally(1)
  | 
    {}		#NoFinally(0)
  ) 			
)
}

void AssertStatement() : {}
{
  "assert" Expression()
  ( ";" #AssertStatement(1)
  | ":" Expression() ";" #AssertMessageStatement(2)
  )
}
  
/* 
%-- Done - only gen for Name
    Check where it's used and verify that no need to create node
*/
void Identifier(JavaNode n) : { Token t; }
{
  t=<IDENTIFIER>
  { n.setInfo(t.image.intern()); }
}

 






