/*
 * ProxyNodePanel.java
 *
 * Created on March 28, 2002, 5:23 PM
 */

package edu.cmu.cs.fluid.mvc;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableModel;

import edu.cmu.cs.fluid.ir.IRNode;
import edu.cmu.cs.fluid.ir.SlotInfo;

/**
 * Panel containing a table of proxy nodes and their attribute values.
 *
 * @author Aaron Greenhouse
 */
public class ProxyNodePanel extends javax.swing.JPanel
{
  /**
   * The model being rendered/observed.
   */
  private final Model model;
  
  /**
   * Table model for the model attributes.
   */
  private final TableModel proxyModel;

  
  
  /** Creates new form ProxyNodePanel */
  public ProxyNodePanel( final Model mod )
  {
    model = mod;
    proxyModel = new ProxyModel( model );
    
    initComponents();
    proxyNodeTable.setModel( proxyModel );
  }
  
  
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    jScrollPane1 = new javax.swing.JScrollPane();
    proxyNodeTable = new javax.swing.JTable();

    setLayout(new java.awt.BorderLayout());

    setBorder(new javax.swing.border.TitledBorder(new javax.swing.border.EtchedBorder(), "Proxy Nodes", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Arial Black", 0, 11)));
    proxyNodeTable.setModel(new javax.swing.table.DefaultTableModel(
      new Object [][]
      {
        {null, null, null, null},
        {null, null, null, null},
        {null, null, null, null},
        {null, null, null, null}
      },
      new String []
      {
        "Title 1", "Title 2", "Title 3", "Title 4"
      }
    ));
    jScrollPane1.setViewportView(proxyNodeTable);

    add(jScrollPane1, java.awt.BorderLayout.CENTER);

  }//GEN-END:initComponents
  
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JTable proxyNodeTable;
  // End of variables declaration//GEN-END:variables
}



/**
 * Table model for rendering the values of proxy nodes.  Assumes that no
 * attributes are added after the model is created.  This is, in general,
 * a false assuption, but true enough for current purposes.
 */
final class ProxyModel
extends AbstractTableModel
implements ModelListener
{
  /** String for undefined attributes. */
  private static final String UNDEFINED = "<Undefined>";

  /** Column name for the IRNode column. */
  private static final String IRNODE_HEADER = "Node";
 
  /** Column name for the IRNode column. */
  private static final int IRNODE_IDX = 0;
 
  
  
  /** The model whose attributes are being tabled. */
  private final Model model;
  
  /** Cache of the attribute names */
  private final String[] attrNames;
  
  /** The attribute value storage for the different attributes. */
  private final SlotInfo[] values;

  /** Ordered list of the nodes in the model (Cache). */
  private final List<IRNode> nodes;
  
  /** Cache of the PROXY_NODE attribute */
  private final SlotInfo<IRNode> proxyNodeSI;
  
  
  
  public ProxyModel( final Model mod )
  {
    model = mod;
    proxyNodeSI = model.getNodeAttribute( ConfigurableView.PROXY_NODE );
    
    /* Cache the attributes */
    final List<String> names = new ArrayList<String>( 10 );
    final List<SlotInfo> attrs = new ArrayList<SlotInfo>( 10 );
    final Iterator i = model.getNodeAttributes();
    while( i.hasNext() ) {
      final String attr = (String) i.next();
      names.add( attr );
      attrs.add( model.getNodeAttribute( attr ) );
    }
    attrNames = names.toArray( new String[0] );
    values = attrs.toArray( new SlotInfo[0] );
    nodes = new ArrayList<IRNode>();
    updateNodes();
    
    model.addModelListener( this );
  }
  
  
  
  /**
   * Iterate through the list of nodes in the model and, if that node 
   * has a proxy node, add the proxy node.
   */
  private void updateNodes()
  {
    nodes.clear();
    final Iterator<IRNode> i = model.getNodes();
    while( i.hasNext() ) {
      final IRNode node = i.next();
      final IRNode proxyNode = node.getSlotValue( proxyNodeSI );
      if( proxyNode != null ) nodes.add( proxyNode );
    }
  }
  
  
  @Override
  public int getColumnCount()
  {
    return 1 + attrNames.length;
  }
  
  @Override
  @SuppressWarnings("unchecked")
  public Class getColumnClass( final int idx )
  {
    return String.class;
  }
  
  @Override
  public String getColumnName( final int idx )
  {
    if( idx == IRNODE_IDX ) return IRNODE_HEADER;
    else return attrNames[idx-1];
  }
  
  @Override
  public int getRowCount()
  {
    return nodes.size();
  }
  
  @Override
  public Object getValueAt( final int rowIdx, final int colIdx )
  {
    try {
      final IRNode node = nodes.get( rowIdx );
      if( colIdx == IRNODE_IDX ) {
        return model.idNode( node );
      } else if( colIdx <= attrNames.length ) {
        final int attrIdx = colIdx - 1;
        if( node.valueExists( values[attrIdx] ) ) {
          return model.nodeValueToString( node, attrNames[attrIdx] );
        } else {
          return UNDEFINED;
        }
      } else {
        return null;
      }
    } catch( IndexOutOfBoundsException e ) {
      return null;
    }
  }  

  @Override
  public void breakView( final ModelEvent e )
  {  
    if(e.shouldCauseRebuild()) {
      updateNodes();
      fireTableDataChanged();
    }
  }
  
  @Override
  public void addedToModel(final Model m) {
    // do nothing
  }
  
  @Override
  public void removedFromModel(final Model m) {
    // do nothing;
  }
}
