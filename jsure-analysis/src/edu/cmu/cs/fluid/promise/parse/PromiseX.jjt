// $Header$
/**
%- Copyright
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */
/*
 * Author: Edwin Chan
 * Modified: 8/6/02 (from the Java grammar)
 * 
 * Designed to parse the following:
 *
%- Options
 */
options {
  JAVA_UNICODE_ESCAPE = true;
  MULTI = false;
  NODE_DEFAULT_VOID=true;
  NODE_FACTORY=true;
  // DEBUG_PARSER=true;
  // COMMON_TOKEN_ACTION=true;
  // NODE_SCOPE_HOOK=true;
  JDK_VERSION = "1.5";
}

/*
%- Parser code
*/
PARSER_BEGIN(PromiseParser)

package edu.cmu.cs.fluid.promise.parse;

import edu.cmu.cs.fluid.java.*;
import java.util.*;
import java.util.logging.*;
import java.io.*;
import java.lang.reflect.*;
import edu.cmu.cs.fluid.promise.parse.SimpleNode;
import edu.cmu.cs.fluid.parse.JJNode;
 
@SuppressWarnings("all")
public class PromiseParser {
  /**
   * Logger for this class
   */
  static final Logger LOG = Logger.getLogger("ECLIPSE.fluid.promise");

  private static final String prefix = "Start_";
    
  private static PromiseParser parser = null;
  private static Map<String,Method> tags = null;
  private static Map<String,Method> unused = null;

  public static void main(String args[]) {
    Runtime r = Runtime.getRuntime();
    System.out.println("\nInitial footprint : "+r.totalMemory()+" bytes");
    long startTime = System.currentTimeMillis();
    JavaNode[] nodes = parse(args);

    long parseTime = System.currentTimeMillis();
    System.out.println("\nAfter parsing:      "+r.totalMemory()+" bytes");
    for(int i=0; i<nodes.length; i++) {
      System.out.println("Line #"+i);
      if (nodes[i] != null) JavaNode.dumpTree(System.out, nodes[i], 1);
    }

    long endTime = System.currentTimeMillis();
    System.out.println("\nFinal footprint :   "+r.totalMemory()+" bytes");
    printDiff("\nElapsed parse time: ", startTime, parseTime);
    printDiff("\nElapsed print time: ", parseTime, endTime);
    
    printUnused();
  }
  
  public static void printDiff(String s, long start, long end) {
    long time = end - start;
    long mins = time / (60 * 1000);
    long msecs = time % (60 * 1000);

    System.out.println(s+mins+":"+(msecs/1000.0));
  }

  public static JavaNode[] parse(String args[]) {
    initTags();
    
    // final PromiseParser parser = new PromiseParser(new StringReader(""));
    InputStream in;
    
    if (args.length == 0) {
      System.out.println("Promise Parser:  Reading from standard input . . .");
      in = System.in;
    } 
    else if (args.length == 1) {
      System.out.println("Promise Parser:  Reading from file " + args[0] + " . . .");
      try {
        in = new java.io.FileInputStream(args[0]);
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Java Parser:  File " + args[0] + " not found.");
        return new JavaNode[0];
      }
    } else { 
      System.out.println("Java Parser:  Usage is one of:");
      System.out.println("         java PromiseParser < inputfile");
      System.out.println("OR");
      System.out.println("         java PromiseParser inputfile");
      return new JavaNode[0];
    }
    try {
      final BufferedReader br = new BufferedReader(new InputStreamReader(in));
      final List lines = new ArrayList();

      String line = br.readLine();
      while (line != null) {
        lines.add(line);
        line = br.readLine();
      }
	  final JavaNode[] nodes = new JavaNode[lines.size()];      
      for(int i=0; i<lines.size(); i++) {
        final String promise     = (String) lines.get(i);
    	final StringTokenizer st = new StringTokenizer(promise);
    	final String result      = st.nextToken(); // OK or BAD or #
    	
    	final boolean ok;
        if (result.startsWith("#")) {
  	      System.out.println("Ignoring line#"+i+": "+promise);
  	      System.out.println();
  	      continue;  	  
  	    } else if (result.equals("OK")) {
  	      ok = true;
  	    } else if (!result.equals("BAD")) {
  	      System.out.println("Unknown result: "+promise);
  	      continue;
  	    } else {
  	      ok = false;
  	    }
        try {
  	      final String keyword     = st.nextToken();
  	      final String rest        = promise.substring(promise.indexOf(keyword)+keyword.length());      
  	      JavaNode n = null;
  	    
  	      System.out.println("Parsing line#"+i+": "+promise);      
    	  n = parsePromise(keyword, rest);
          nodes[i] = n;
          if (n != null) {
            if (!ok) {
              // Should not have been successful.  
              System.out.println("Parse should have failed.");            
            }
          } else if (ok) { 
            // n is null 
            System.out.print("Parse should have succeeded, but null result.");
          }
        } catch(Exception e) {
          if (ok) {
            System.out.print("Parse should have succeeded.  Trying to continue after: ");
            System.out.println(e.getMessage());
            e.printStackTrace();
          } else {
            // Supposed to fail, so ignore this.
          }
        }
        System.out.println();
      }
      System.out.println("Thank you.");
      return nodes;	
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
    return null;
  }
  
  public static void printUnused() {
    if (unused.isEmpty()) {
      System.out.println("No unused tags");
      return;
    }
    System.out.println("\nThe following @ tags were not exercised:\n");
    for(String tag : unused.keySet()) {
      System.out.println(tag);
    }
  }

  public static void initTags() {
    LOG.fine("Setting up tags");
    if (parser == null) {
      parser = new PromiseParser(new StringReader(""));    
      LOG.fine("Created a parser");
    }
    if (tags != null) {
      return;
    }
    tags = new HashMap<String,Method>();
    
    final Method[] methods = parser.getClass().getDeclaredMethods();
    for(int i=0; i<methods.length; i++) {
      Method m = methods[i];
	  LOG.fine("Looking at "+m.getName()+"()");

      // look for methods like "JavaNode Start_region()"
      if (m.getName().startsWith(prefix) &&
          m.getParameterTypes().length == 0 &&
          m.getReturnType() == JavaNode.class) 
      {
        final String tag = m.getName().substring(prefix.length());
        tags.put(tag, m);
      }
    }
    unused = new HashMap<String,Method>(tags);
  }

  public static Iterator<String> getParseableTags() {
    initTags();
    return tags.keySet().iterator();
  }

  /* Should be called after all tags are initialized
   
  public static void setupTagRules() {
    initTags();
    
    Iterator it = tags.keySet().iterator();
    while (it.hasNext()) {
      String tag  = (String) it.next();
      
      if (!EclipsePromiseParser.ruleExists(tag)) {
        LOG.fine("Adding rule for @"+tag);
        EclipsePromiseParser.addRule(new AbstractPromiseParserRule(tag) {});
      } else {
        LOG.warning("Rule already exists for tag "+tag);
      }
    }
  }
  */
  
  /**
   * Returns non-null if parseable
   */
  private static Method parseableAs(String keyword) {
    initTags();
    
    return (Method) tags.get(keyword);
  }

  public static boolean isParseable(String keyword) {
    return (parseableAs(keyword) != null);
  }

  private static JavaNode rootNode() {
    return (JavaNode) PromiseParser.jjtree.rootNode();
  }
  
  private static final Object[] mArgs = new Object[0];

  public static Token findPackageDeclaration(String src) throws ParseException {
    parser.ReInit(new StringReader(src));
	PromiseParser.jjtree.reset();
	return ExplicitPackageDeclaration();
  }

  public static JavaNode parsePromise(String keyword, String rest) 
    throws ParseException, IOException 
  {
    final Method m = parseableAs(keyword);
    if (m == null) {
      return null;
    }
    try {
      parser.ReInit(new StringReader(rest));
	  PromiseParser.jjtree.reset();
	  JavaNode node = (JavaNode) m.invoke(parser, mArgs);
      unused.remove(keyword);
      return node;
	  // return rootNode();
	} catch (InvocationTargetException e) {
	  Throwable t =  e.getCause();
	  if (t instanceof ParseException) {
	    throw ((ParseException) t);
	  }
      LOG.log(Level.SEVERE, "Unexpected InvocationTargetException", e);
      return null;	  
    } catch (Exception e) {
      // NoSuchMethodException, SecurityException,
      // IllegalAccessException, IllegalArgumentException,
      // InvocationTargetException
      // it should never come here
      LOG.log(Level.SEVERE, "Trying to parse @"+keyword+" - "+rest);
      LOG.log(Level.SEVERE, "Unable to invoke '"+m.getName()+"' -- "+e.getMessage(), e);
      return null;
    }
  } 
  
  // Object, not OBJECT
  static boolean isCapitalized(String token) {
    boolean result = Character.isUpperCase(token.charAt(0));
    
    if (token.length() == 1) {
      return result;
    }
   check_if_all_caps:
    if (result) {
      for(int i=token.length()-1; i>1; i--) {
        if (Character.isLowerCase(token.charAt(i))) {
          break check_if_all_caps;
        }
      }
      result = false;
    }
    // FIX
    if (LOG.isLoggable(Level.FINE)) { LOG.fine("isCapitalized: Looking at "+token+": "+result); }
    return result;
  } 
}

PARSER_END(PromiseParser)
/*
%- Token definitions
*/

/*
%-- Skip
*/
SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/*
%-- Special: comments
*/
// 1st hack (obsolete now with tags in specific places)
// SKIP: { <ANNOTATION: "//@"> } 

SPECIAL_TOKEN : /* COMMENTS */
{
// <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r","@"]) (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
| <FORMAL_COMMENT:    "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/**
 * Summary comment (possibly with in-line tags or HTML).
 * Other comments
      In-line code
      ...
 * Series of @ tags
*/

/*
%-- Reserved words
*/
TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < ONLY: "only" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SUPERCALIFRAGILISTICEXPIALIDOCIOUS: "supercalifragilisticexpialidocious" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >

  // ADDED
| < REGION : "region" > 
| < NOTHING : "nothing" >
| < INTO : "into" >
| < ANY : "any" >
| < IS : "is" >
| < PROTECTS : "protects" >
| < ENCLOSES : "encloses" >
}

/*
%-- Literals
*/
TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}
/*
%-- Identifiers
*/
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < WILDCARD_ID: (<STAR> <ID_FRAG> <WILDCARD_REST> |
                  <IDENTIFIER> <STAR> (<ID_FRAG>)? <WILDCARD_REST>
                 ) 
  >
|  
  < #ID_FRAG: (<LETTER>|<DIGIT>)+ > 
|
  < #WILDCARD_REST: ((<STAR>)? <ID_FRAG> )* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
/*
%-- Separators
*/
TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/*
%-- Operators
*/
TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
%-* THE JAVA PROMISE GRAMMAR STARTS HERE *

   Exclude invariants, container, condition

 *****************************************/

void END() : {}
{
  [ ";" ]
  <EOF>
}

/*
 * Entry points based on tag
 */

JavaNode Start_TRoleImport() : {}
{
  // BAD
  NewRegionDeclaration() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Region-related: region, mapRegion, mapFields, mapInto, aggregate
 ******************************************************************/

JavaNode Start_Region() : {}
{
  NewRegionDeclaration() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/*
JavaNode Start_MapRegion() : {}
{
  RegionMapping() END()
  { return (JavaNode)jjtree.rootNode(); }
}
*/

JavaNode Start_MapFields() : {}
{
  FieldMappings() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_InRegion() : {}
{
  RegionSpecification() END()
  { return (JavaNode)jjtree.rootNode(); } 
}

JavaNode Start_MapInto() : {}
{
  RegionSpecification() END()
  { return (JavaNode)jjtree.rootNode(); } 
}

JavaNode Start_Aggregate() : {}
{
  MappedRegionSpecification() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Effects-related: reads, writes
 ******************************************************************/

JavaNode Start_Reads() : {}
{
  EffectsSpecification() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_Writes() : {}
{
  EffectsSpecification() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Uniqueness-related: unique, borrowed
 ******************************************************************/

JavaNode Start_Unique() : {}
{
  SimpleExpressionList() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_Borrowed() : {}
{
  SimpleExpressionList() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Lock-related: lock, policyLock, returnsLock, isLock, requiresLock
 ******************************************************************/

JavaNode Start_Lock() : {} 
{
  LockDeclaration() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_PolicyLock() : {} 
{
  PolicyLockDeclaration() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_ReturnsLock() : {} 
{
  LockName() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_IsLock() : {} 
{
  LOOKAHEAD(CommentedLockName())
  CommentedLockName() END()
  { return (JavaNode)jjtree.rootNode(); }
|
  SimpleLockName() END()
  { return (JavaNode)jjtree.rootNode(); }    
}  

JavaNode Start_RequiresLock() : {}
{
  LockNames() END()
  { return (JavaNode)jjtree.rootNode(); }  
}

/******************************************************************
 ** notNull
 ******************************************************************/
 
JavaNode Start_NotNull() : {}
{
  SimpleExpressionList() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** useTypeWherePossible
 ******************************************************************/
 
 JavaNode Start_UseTypeWherePossible() : {}
{
  NamedType() END()
  { return (JavaNode)jjtree.rootNode(); }  
}

/******************************************************************
 ** starts (thread effects)
 ******************************************************************/
 
 JavaNode Start_Starts() : {}
{
  StartsSpecification() END()
  { return (JavaNode)jjtree.rootNode(); }  
}

/******************************************************************
 ** usedBy and subtypedBy
 ******************************************************************/
 
 JavaNode Start_UsedBy() : {}
{
  UsedBySpecification() END()
  { return (JavaNode)jjtree.rootNode(); }  
}

 JavaNode Start_SubtypedBy() : {}
{
  SubtypedBySpecification() END()
  { return (JavaNode)jjtree.rootNode(); }  
}

/******************************************************************
 ** Constructs for scoped promises
 ******************************************************************/

JavaNode Start_Promise() : {}
{
  ScopedPromise() END()
  { return (JavaNode)jjtree.rootNode(); }    
}

JavaNode Start_Assume() : {}
{
  ScopedPromise() END()
  { return (JavaNode)jjtree.rootNode(); }    
}

/******************************************************************
 ** Constructs for region declarations
 ******************************************************************/

// @region 
void NewRegionDeclaration() #NewRegionDeclaration : {}
{
  { JJNode.tree.setSubtree(jjtThis, 0, null); }
  accessModifiers(jjtThis) Identifier(jjtThis) 
  [ "extends" RegionSpecification() ]
}

void RegionSpecification() : {}
{
  LOOKAHEAD(QualifiedRegionName()) 
  QualifiedRegionName() 
|
  RegionName() 
|
  "[" "]"  
  { jjtThis.setInfo("[]"); }
  #RegionName(0)
}

void RegionName() #RegionName(0) : {}
{
  Identifier(jjtThis)
}

void QualifiedRegionName() #QualifiedRegionName(1) : {}
{
  NamedType() "#" Identifier(jjtThis) // is this right?
}

/******************************************************************
 ** Constructs for region mapping
 ******************************************************************/

// Both for mapping regions to super-regions and for aggregation
// @mapRegion
void RegionMapping() #RegionMapping(2) : {}
{
  RegionSpecification() <INTO> RegionSpecification()
}

// @aggregate
void MappedRegionSpecification() #MappedRegionSpecification : {}
{
  RegionMapping() ( "," RegionMapping() )*
}

// @mapFields
void FieldMappings() #FieldMappings(2) : {}
{
  RegionSpecifications() <INTO> RegionSpecification()
}

void RegionSpecifications() #RegionSpecifications : {}
{
  RegionName() ( "," RegionName() )*
}

/***
***************************************************************
 ** Constructs for effect declarations
 ******************************************************************/

// @reads, @writes
void EffectsSpecification() #EffectsSpecification : {} 
{
  "nothing"  
|
  EffectSpecification() ( "," EffectSpecification() )*
}

// isWrite
//
void EffectSpecification() #EffectSpecification(2) : {}
{
  LOOKAHEAD(2)
  SimpleEffectExpression() "." RegionSpecification()
|
  ImplicitThisEffectSpecification()
}

// A variable for use with RegionSpecification
// 
// what about the return value?
void SimpleEffectExpression() : {}
{
  LOOKAHEAD(AnyInstanceExpression())  
  AnyInstanceExpression()  
|
  LOOKAHEAD(QualifiedThisExpression())
  QualifiedThisExpression()
|
  LOOKAHEAD({isCapitalized(getToken(1).image)})
  TypeExpression()
|
  LOOKAHEAD(<IDENTIFIER> "." <IDENTIFIER> ".")
  TypeExpression()
|
  "super" 		   #SuperExpression(0) 
|
  SimpleExpression()
}

void ImplicitThisEffectSpecification() : { SimpleNode n; }
{
  { n = (SimpleNode)SimpleNode.jjtCreate(JJTTHISEXPRESSION);
    // LOG.fine("Creating implicit this");
    jjtree.openNodeScope(n);
    jjtree.closeNodeScope(n, 0);
  }
  RegionName()
}

void AnyInstanceExpression() #AnyInstanceExpression(1) : {}
{
  <ANY> "(" NamedType() ")"
}

/******************************************************************
 ** Constructs for lock declarations
 ******************************************************************/

void LockDeclaration() #LockDeclaration(2) : {}
{
  Identifier(jjtThis) <IS> LockExpression() <PROTECTS> RegionSpecification()
}

void PolicyLockDeclaration() #PolicyLockDeclaration(1) : {}
{
  Identifier(jjtThis) <IS> LockExpression()
}

void LockExpression() : {}
{
  LOOKAHEAD(QualifiedLockExpression())
  QualifiedLockExpression() 
|
  SimpleLockExpression()  
}

void QualifiedLockExpression() : {}
{
  LOOKAHEAD(QualifiedFieldRef())
  QualifiedFieldRef()
|
  LOOKAHEAD(QualifiedClassLockExpression())
  QualifiedClassLockExpression()
|
  QualifiedThisExpression()
}

void QualifiedClassLockExpression() #QualifiedClassLockExpression(1) : {}
{
  NamedType() ":" "class"
}

void SimpleLockExpression() : {}
{
  LOOKAHEAD(ImplicitClassLockExpression())
  ImplicitClassLockExpression()
|
  "this"		   #ThisExpression(0)
|
  FieldRef(jjtThis) #FieldRef(1)
}

void ImplicitClassLockExpression() #ImplicitClassLockExpression(0) : {}
{
(
  "class"
|
  "this" "." "class"
)
}

/******************************************************************
 ** Constructs for lock references
 ******************************************************************/

void LockNames() #LockNames : {}
{
  LockName() ( "," LockName() )*
}

void LockName() : {}
{
  LOOKAHEAD(QualifiedLockName())
  QualifiedLockName()
|
  SimpleLockName() 
}

void SimpleLockName() #SimpleLockName(0) : {}
{
  Identifier(jjtThis) 
}

void CommentedLockName() #SimpleLockName(0) : {}
{
  CommentIdentifier(jjtThis) Identifier(jjtThis) 
}

void QualifiedLockName() #QualifiedLockName(1) : {}
{
  LOOKAHEAD(TypeQualifiedLockName(jjtThis))
  TypeQualifiedLockName(jjtThis)
|
  LOOKAHEAD(InnerClassLockName(jjtThis))
  InnerClassLockName(jjtThis)
|
  SimpleExpression() "." Identifier(jjtThis)
}

void TypeQualifiedLockName(JavaNode n) : {}
{
  TypeExpression() ":" Identifier(n)  
}

void InnerClassLockName(JavaNode n) : {} 
{
  QualifiedThisExpression() ":" Identifier(n)
}

void QualifiedThisExpression() #QualifiedThisExpression(1) : {}
{
  NamedType() "." "this"
}

/******************************************************************
 ** Constructs for Color declarations
 ******************************************************************/

void ColorName() #ColorName(0) : {}
{
  DottedName(jjtThis)
}

void ColorNames() : {}
{
  ColorName() ( "," ColorName() )*
}

void ColorDeclaration() #ColorDeclaration : {}
{
  ColorNames()
}

JavaNode Start_Color() : {}
{
  ColorDeclaration() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for Color imports
 ******************************************************************/

void ColorImport() #ColorImport : {}
{
    ( LOOKAHEAD( PackageName(null) "." "*" )	
    (PackageName(jjtThis) "." "*")	#DemandName(0) 
  |  DeclaredTypeName()	
  )
  
}

JavaNode Start_ColorImport() : {}
{
  ColorImport() END()
  {return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for Color grant, revoke, incompatibleColors
 ******************************************************************/

void ColorGrant() #ColorGrant : {}
{
  ColorNames()
}

JavaNode Start_Grant() : {}
{
  ColorGrant() END()
  { return (JavaNode)jjtree.rootNode(); }
}

void ColorRevoke() #ColorRevoke : {}
{
  ColorNames()
}

JavaNode Start_Revoke() : {}
{
  ColorRevoke() END()
  { return (JavaNode)jjtree.rootNode(); }
}

void ColorIncompatible() #ColorIncompatible : {}
{
  ColorNames()
}

JavaNode Start_IncompatibleColors() : {} 
{ 
  ColorIncompatible() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for Color colorConstraint, colorContext
 ******************************************************************/

void ColorRequire() #ColorRequire : {}
{
  ColorSpec() 
}


JavaNode Start_ColorConstraint() : {}
{
  ColorRequire()  END()
  { return (JavaNode)jjtree.rootNode(); }
}

void ColorContext() #ColorContext : {}
{
  ColorSpec() 
}

JavaNode Start_ColorContext() : {}
{
  ColorContext()  END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for ColorSpec
 ******************************************************************/

void ColorSpec() : {}
{ 
  ( ColorName()
|
  ColorNot()
|
  "(" ColorExpr() ")" )
}

void ColorNot() #ColorNot(1) : {}
{
  "!" ColorName()
}

void ColorExpr() : {}
{
  LOOKAHEAD(ColorOr())
  ColorOr()
|
  LOOKAHEAD(ColorAnd())
  ColorAnd()
}

void ColorAnd() #ColorAnd(>1) : {}
{
  ColorAndElem() "&" ColorAndElem() [ "&" ColorAndElem() ]
}

void ColorAndElem() : {}
{
  ColorNot()
|
  ColorName()
}

void ColorAndParen() #ColorAndParen(>1) : {}
{
  "("  ColorAndElem() "&" ColorAndElem() [ "&" ColorAndElem() ] ")"
}

void ColorOr() #ColorOr(>1) : {}
{
  ColorOrElem() "|" ColorOrElem() [ "|" ColorOrElem() ]
}
 
void ColorOrElem() : {}
{
  (  ColorNot()
|
  ColorName()
|
  ColorAndParen() )
}

/******************************************************************
 ** Constructs for Color colorRename
 ******************************************************************/
 
void ColorRename() #ColorRename : {}
{
  ColorName() "for" ColorSpec() 
}

JavaNode Start_ColorRename() : {}
{
  ColorRename() END()

  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for Color colorCardinality
 ******************************************************************/
 
void ColorCardChoice() : {}
{
  ColorCard1()
|
  ColorCardN()
}

void ColorCard1() #ColorCard1 : 
{ Token t; 
}
{
  t=<INTEGER_LITERAL>
}

void ColorCardN() #ColorCardN : {}
{
  "*"
}

void ColorCardinality() #ColorCardinality(2) : {}
{
  ColorName() ColorCardChoice()
}


JavaNode Start_ColorCardinality() : {}
{
  ColorCardinality() END()

  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for Color colorizedRegion, colorConstrainedRegions
 ******************************************************************/

void ColorizedRegion() #ColorizedRegion : {}
{
   RegionSpecifications()
}

JavaNode Start_ColorizedRegion() : {}
{
  ColorizedRegion()  END()
  { return (JavaNode)jjtree.rootNode(); }
}

void ColorConstrainedRegions() #ColorConstrainedRegions : {}
{
   ColorSpec() "for" RegionSpecifications() 
}


JavaNode Start_ColorConstrainedRegions() : {}
{
  ColorConstrainedRegions()  END()
  { return (JavaNode)jjtree.rootNode(); }
}
   
/******************************************************************
 ** Constructs for Modules
 ******************************************************************/

JavaNode Start_Vis() : {}
{
   API() END()
   { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_Export() : {}
{
   API() END()
   { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_Module() : {}
{
   Module() END()
   { return (JavaNode)jjtree.rootNode(); }
}

void API() #API(0) : {}
{
  (QualifiedName(jjtThis))?
}

void Module() : {}
{
  LOOKAHEAD(EnclosingModule())
  EnclosingModule()
|
  LOOKAHEAD(ScopedModule())
  ScopedModule()
|
  SimpleModule()
}

void SimpleModule() #Module(0) : {}
{
  QualifiedName(jjtThis)
}

void Modules() #Modules : {}
{
  (SimpleModule() ( "," SimpleModule() )*)?
}

void EnclosingModule() #EnclosingModule(1) : {}
{
  QualifiedName(jjtThis) "encloses" Modules()
}

void ScopedModule() #ScopedModule(1) : {}
{
  // interpreted as the compilation unit the type is in
  QualifiedName(jjtThis) "for" PromiseTarget()
}

/******************************************************************
 ** Constructs for Tainted
 ******************************************************************/
JavaNode Start_Tainted() : {} 
{ 
  SimpleExpressionList() END()
  { return (JavaNode)jjtree.rootNode(); }
}

JavaNode Start_NotTainted() : {} 
{ 
  SimpleExpressionList() END()
  { return (JavaNode)jjtree.rootNode(); }
}

/******************************************************************
 ** Constructs for @starts
 ******************************************************************/

void StartsSpecification() #StartsSpecification : {}
{
  "nothing"  
//|
//  StartsEntry() ( "," StartsEntry() )*
}

void StartsEntry() : {}
{
  LOOKAHEAD(2) NamedType()
| NamedType() "*"
| LOOKAHEAD(3) "<" SimpleExpression() ">"
| "<" SimpleExpression() ">" "*"
}

/******************************************************************
 ** Constructs for @usedBy and @subtypedBy
 ******************************************************************/

void UsedBySpecification() #UsedBySpecification : {}
{
  NamedType() ( "," NamedType() )*
}

void SubtypedBySpecification() #SubtypedBySpecification : {}
{
  NamedType() ( "," NamedType() )*
}

/******************************************************************
 ** Constructs for scoped promises
 ******************************************************************/

void ScopedPromise() #ScopedPromise(1) : {}
{
  Promise(jjtThis) 
( "for" PromiseTarget() |
  nothing() #PromiseTarget
)
}

void Promise(JavaNode n) : { Token t; int i = 1; } 
{
  t=<STRING_LITERAL>
  // Need to eliminate the quotes
  { i = t.image.startsWith("\"@") ? 2 : 1;
    n.setInfo(t.image.substring(i, t.image.length()-1)); 
  }
}

/******************************************************************
 ** Constructs for promise targets
 ******************************************************************/

void PromiseTarget() #OrTarget(>1) : {}
{
  AndTarget() [ "|" PromiseTarget() ]
}

void AndTarget() #AndTarget(>1) : {}
{
  BaseTarget() [ "&" AndTarget() ]
}

void BaseTarget() : {}
{
  LOOKAHEAD(ConstructorDeclPattern())
  ConstructorDeclPattern()
|
  LOOKAHEAD(MethodDeclPattern())
  MethodDeclPattern() 
|
  LOOKAHEAD(NoReturnMethodDeclPattern())
  NoReturnMethodDeclPattern() 
|
  LOOKAHEAD(FieldDeclPattern())
  FieldDeclPattern()
|
  LOOKAHEAD(2)
  TypeDeclPattern()
|
  "!" "(" PromiseTarget() ")" #NotTarget(1)
|
  "(" PromiseTarget() ")"
}

/******************************************************************
 ** Constructs for basic patterns for Java declarations
 ******************************************************************/

void ConstructorDeclPattern() #ConstructorDeclPattern(2) : {}
{
  ModifierPattern(jjtThis)
  TypeQualifierPattern(jjtThis)
  "new"
  MethodSigPattern()
  ThrowsPattern()
}

// Factors out the main part of a method pattern
// from the MethodDeclPatterns below
void MethodMatchPattern(JavaNode n) : {}
{ 
  TypeQualifierNodePattern()
  MethodNamePattern(n)
  MethodSigPattern()
}

void MethodDeclPattern() #MethodDeclPattern(4) : {}
{ 
  ModifierPattern(jjtThis)
  ReturnTypePattern()
  MethodMatchPattern(jjtThis)
  ThrowsPattern()
}

void NoReturnMethodDeclPattern() #MethodDeclPattern(4) : {}
{ 
  ModifierPattern(jjtThis)
  NoTypeSigPattern()
  MethodMatchPattern(jjtThis)
  ThrowsPattern()
}


void FieldDeclPattern() #FieldDeclPattern(2) : {}
{
  ModifierPattern(jjtThis)
  TypeSigPattern()
  TypeQualifierNodePattern() 
  FieldNamePattern(jjtThis)
}

void TypeDeclPattern() #TypeDeclPattern(0) : {}
{
  ModifierPattern(jjtThis)
  OptQualifiedTypeNamePattern(jjtThis)
}

/******************************************************************
 ** Constructs for modifiers
 ******************************************************************/

void ModifierPattern(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  [
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); }  
  ]
  [
    "static"    { JavaNode.setModifier(n, JavaNode.STATIC, true); } 
  | "!" "static" { JavaNode.setModifier(n, JavaNode.INSTANCE, true); }
  ]
/*
  ( "public" 
  | "protected"
  | "private"
  | "abstract"
  | "synchronized"
  | "final"
  )*
*/
}

/******************************************************************
 ** Constructs for type qualifiers
 ******************************************************************/

// Creates a TypeQualifierPattern node
void TypeQualifierNodePattern() #TypeQualifierPattern(0) : {}
{
  TypeQualifierPattern(jjtThis)
}

// No node created
void TypeQualifierPattern(JavaNode n) : {}
{
  ( LOOKAHEAD(QualifiedTypeNamePattern(n) ":") 
    QualifiedTypeNamePattern(n) ":" 
  | 
    [LOOKAHEAD(TypeNamePattern(n) ":")   
    TypeNamePattern(n) ":"
    ]
  )
}

// Type qualified by a package 
void QualifiedTypeNamePattern(JavaNode n) : {}
{
  PackagePrefix(n) WildcardClassNames(n) 
}

void TypeNamePattern(JavaNode n) : {}
{
  WildcardClassNames(n) 
}
void PackagePrefix(JavaNode n) : {}
{
  WildcardPackageName(n) ":" 
}

// Used by TypeDeclPattern
void OptQualifiedTypeNamePattern(JavaNode n) : {}
{
  LOOKAHEAD(QualifiedTypeNamePattern(n))
  QualifiedTypeNamePattern(n)
|
  TypeNamePattern(n)
}


/******************************************************************
 ** Constructs for method and field name patters
 ******************************************************************/

void MethodNamePattern(JavaNode n) : {}
{
  // for now
  WildcardIdentifier(n)
/*
|
  Wildcard(n)
*/
|
  SeqWildcard(n)
}

void FieldNamePattern(JavaNode n) : {}
{
  // for now
  WildcardIdentifier(n)
/*
|
  Wildcard(n)
*/
}

/******************************************************************
 ** Constructs for return types and types in method signatures
 ******************************************************************/

// Used for return types
void ReturnTypePattern() : {}
{ 
  "void" #VoidType
|
  TypeSigPattern() 
}

// Used if the return type is not specified
// This causes a problem for the binding code!
void NoTypeSigPattern() #NamedType : {}
{
  nothing()
}

// Like TypeNamePattern, 
// but also handles primitive types and array types
//
void TypeSigPattern() : {}
{
(
  TypeNamePattern(jjtThis) #NamedType
| 
  PrimitiveType()
)
  // HACK: sucks up the node generated above
  [ ( ArrayDims(jjtThis) ) #ArrayType(1) ] 
}

void MethodSigPattern() #MethodSigPattern : {}
{
  "(" SigSeqPattern(jjtThis) ")"
}

void SigSeqPattern(JavaNode n) : {}
{
  TypeSigPattern() ( ","  TypeSigPattern() )* 
|  
  [ SeqWildcard(n) ] 
}

/******************************************************************
 ** Constructs for throws clauses
 ******************************************************************/
 
void ThrowsPattern() : {}
{
  "throws" 
  ( 
    "void" #EmptyThrowsPattern
  | TypeNameSeqPattern(jjtThis) #ThrowsPattern
  ) 
|
  nothing() #NoThrowsPattern
}

void TypeNameSeqPattern(JavaNode n) : {}
{
  TypeNamePattern(jjtThis) #NamedType(0)
  ( ","  TypeNamePattern(jjtThis) #NamedType(0) )* 
|  
  [ SeqWildcard(n) ] 
}

/******************************************************************
 ** Basic constructs
 ******************************************************************/

void nothing() : {} 
{
  (LOOKAHEAD(1) <SUPERCALIFRAGILISTICEXPIALIDOCIOUS>)? 
}

void Wildcard(JavaNode n) : {}
{
  "*"
  { JJNode.setInfo(n, "*"); }
}

void SeqWildcard(JavaNode n) : {}
{
  "**"
  { JJNode.setInfo(n, "**"); }
}


/**
 * @return The position of the end of the package declaration
 */
Token ExplicitPackageDeclaration() : { Token t; }
{
  <PACKAGE> PkgName() 
  t=";"
  { return t; }
}

void PkgName() : {}
{
  <IDENTIFIER>
  ( 
    "." 
    <IDENTIFIER>
  )*
}

void TypeNames() #Implements : {}
{
  NamedType() ( "," NamedType() )*
}

// The name of a type
void TypeExpression() #TypeExpression(1) : {}
{
  NamedType()
}

void NamedType() #NamedType(0) : {}
{
  QualifiedName(jjtThis)
}

void QualifiedFieldRef() #FieldRef(1) :  {}
{
  TypeExpression() ":" Identifier(jjtThis)
}

void FieldRef(JavaNode n) :  {}
{
  Identifier(n)      #ThisExpression(0)
}

void SimpleExpression() : {}
{
  "this"		   #ThisExpression(0)
|
  // parameters
  Identifier(jjtThis)      #VariableUseExpression(0)
}

void SimpleExpressionList() #StatementExpressionList : {}
{
  (SimpleExpression() ( "," SimpleExpression() )*)?
}

/******************************************************************
 ** Utility routines copied from the Java grammar
 ******************************************************************/

void accessModifiers(JavaNode n) : {}
{
  { n.setModifiers(JavaNode.ALL_FALSE); }
  [
    "public"	{ JavaNode.setModifier(n, JavaNode.PUBLIC, true); } 
  | "protected"	{ JavaNode.setModifier(n, JavaNode.PROTECTED, true); } 
  | "private"	{ JavaNode.setModifier(n, JavaNode.PRIVATE, true); } 
  ]
  [ "static"    { JavaNode.setModifier(n, JavaNode.STATIC, true); } ]
}

/******************************************************************
 ** Constructs for primitive types, and array dims
 ******************************************************************/
 
void PrimitiveType() : {}
{
  <BOOLEAN> #BooleanType
|
  "char" #CharType
| 
  "byte" #ByteType
|
  "short" #ShortType
|
  <INT> #IntType
|
  "long" #LongType
|
  "float" #FloatType
|
  "double" #DoubleType
}

void ArrayDims(JavaNode n) : { int count = 0; }
{
  LOOKAHEAD("[" "+")
  "[" "+" "]" 
  { JavaNode.setDimInfo(n, -1); }
|
  ( "[" "]" 
    { count++; }
  )+
  { JavaNode.setDimInfo(n, count); }
}

void QualifiedName(JavaNode n) : 
{ StringBuffer name;
  Token t;
}
{
  t=<IDENTIFIER>
  { name = new StringBuffer(t.image); 
  }
  // FIX to handle inner classes
  ( LOOKAHEAD(2, {!isCapitalized(getToken(0).image)}) 
    "." 
    t=<IDENTIFIER>
    { name.append('.').append(t.image); }
  )*
  { n.setInfo(name.toString().intern()); }
}


void DottedName(JavaNode n) : 
{ StringBuffer name;
  Token t;
}
{
  t=<IDENTIFIER>
  { name = new StringBuffer(t.image); 
  }
  ( LOOKAHEAD(2) "." 
    t=<IDENTIFIER>
    { name.append('.').append(t.image); }
  )*
  { n.setInfo(name.toString().intern()); }
}

/**
 *  All supposed to be capitalized
 *  Allowing wildcards
 */
void WildcardClassNames(JavaNode n) : 
{ StringBuffer name;
  Token t;
}
{
  name=WildcardId(null)
  ( LOOKAHEAD(2) 
    "." 
    { name.append('.'); }
    name=WildcardId(name)
  )*
  { n.setInfo(name.toString().intern()); }
}

// Qualified
void Name(JavaNode n) : 
{ StringBuffer name;
  Token t;
}
{
  t=<IDENTIFIER>
  { name = new StringBuffer(t.image); 
  }
  ( LOOKAHEAD(2) "." 
    t=<IDENTIFIER>
    { name.append('.').append(t.image); }
  )*
  { n.setInfo(name.toString().intern()); }
}

void WildcardPackageName(JavaNode n) :
{ StringBuffer name;
  Token t;
}
{
  t=<IDENTIFIER>
  { name = new StringBuffer(t.image); 
  }
  ( LOOKAHEAD(2) "." 
    /*
    (
      "*"
      { name.append(".*"); }
    |
      "**"
      { name.append(".**"); }
    |    
      t=<IDENTIFIER>
      { name.append('.').append(t.image); }
    )
    */
    (
      { name.append('.'); }
      name=WildcardId(name)
    | 
      "**"
      { name.append(".**"); }
    )
  )*
  { edu.cmu.cs.fluid.java.JavaNode.setComment(n, name.toString().intern()); }
}

void Identifier(JavaNode n) : { Token t; }
{
  t=<IDENTIFIER>
  { n.setInfo(t.image.intern()); }
}

void WildcardIdentifier(JavaNode n) : 
{ StringBuffer name;
}
{
  name=WildcardId(null)
  { n.setInfo(name.toString().intern()); }
}

StringBuffer WildcardId(StringBuffer name) : 
{ Token t;
}
{
/*
  ( // Special support
    "is"
    { if (name != null) name.append("is"); 
      else name = new StringBuffer("is");
    }
  |
    t=<IDENTIFIER>
    { if (name != null) name.append(t.image); 
      else name = new StringBuffer(t.image);
    }
  )
  (
    LOOKAHEAD(2) 
    "*" 
    t=<IDENTIFIER>
    { name.append('*').append(t.image); }
  )*
  [ "*" 
    { name.append('*'); }
  ]
*/
  ( 
    <STAR>
    { if (name != null) name.append("*"); 
      else name = new StringBuffer("*");
    }
  | 
    t=<WILDCARD_ID>
    { if (name != null) name.append(t.image); 
      else name = new StringBuffer(t.image);
    }
  |
    t=<IDENTIFIER>
    { if (name != null) name.append(t.image); 
      else name = new StringBuffer(t.image);
    }
  )
  { return name; }
}

void CommentIdentifier(JavaNode n) : { Token t; }
{
  t=<IDENTIFIER>
  { edu.cmu.cs.fluid.java.JavaNode.setComment(n, t.image.intern()); }
}

/* Note:
   these 'AST' nodes need to be repackaged by the binding resolution 
// void PackageName() : {}
*/
void PackageName(JavaNode n) : {}
{
  Name(n)
}

void DeclaredTypeName() : {}
{
  GeneralClassType()
}

void GeneralClassType() : {}
{
  NamedType()
  ( LOOKAHEAD("<")
    TypeActuals() #ParameterizedType(2)
  |
    LOOKAHEAD(".")
    "." Identifier(jjtThis) #TypeRef(1)
  )*
}

void TypeActuals() #TypeActuals : {}
{
  "<" TypeOrWildcard() ("," TypeOrWildcard())* ">"
}

void TypeOrWildcard() : {}
{
  "?" ( "extends" GeneralClassType() #WildcardExtendsType(1)
         | "super" GeneralClassType() #WildcardSuperType(1)
         | {} #WildcardType(0))
|
  Type()         
}

/*
%- Type, name and expression syntax follows.
 */
/*
%-- Done
*/
void Type() : {}
{
  ( PrimitiveType() | GeneralClassType())
  // HACK: sucks up the node generated above
  [ ( ArrayDims1(jjtThis) ) #ArrayType(1) ]
}

void ArrayDims1(JavaNode n) : { int count = 0; }
{
  ( LOOKAHEAD(2) "[" "]" { count++; } )+
  { JavaNode.setDimInfo(n, count); }
}



