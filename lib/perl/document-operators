#!/usr/local/bin/perl
# $Header: /cvs/fluid/fluid/lib/perl/document-operators,v 1.8 2004/07/28 20:53:04 boyland Exp $

# Create an HTML file documenting the operators.
# It reads in all the operator description files given
# and creates a context free grammar.

$package="";
$header = "";
%typetable = ();
$debug = "false";
$start = "";
%opsyntax = ();
%opsupers = ();
%optable = ();
%opused = ();
$allused = "";
@opfiles = glob("*.op");
%opfiles = ();
foreach $opfile (@opfiles) {
  $opfiles{$opfile} = 1;
}

while ($arg = shift) {
    if ($arg =~ /^-package=(.*)/) {
	$package = $1;
    } elsif ($arg =~ /^-header=(.*)/) {
	$header = $1;
    } elsif ($arg =~ /^-start=(.*)/) {
	$start = $1;
	$opused{$start} = "true";
    } elsif ($arg =~ /^-allused/) {
	$allused = "true";
    } elsif ($arg =~ /^-debug=(.*)/) {
	$debug = $1;
    } elsif ($arg =~ /^-supers:(.*)=(.*)/) {
	$opsupers{$1} = $2;
	foreach $super (split(":",$2)) {
	    $opused{$super} = "true";
	}
	$typetable{$1}=$1;
    } elsif ($arg =~ /^([A-Za-z]+):([A-Za-z]+)$/) {
	$typetable{$2} = $1;
    } elsif ($arg =~ /^(.*).op$/) {
        unless (defined($opfiles{$arg})) {
	  push @opfiles, $arg;
	  $opfiles{$arg} = 1;
	}
    } else {
      die("Unrecognized argument $arg");
    }
}

foreach $arg (@opfiles)
{
    {
	open(OPFILE,$arg) || die("Could not read operator file $arg");
	do {
	    $line = <OPFILE>;
	} until (!$line || $line =~ /^[a-z ]*operator/);
	if (!$line) {
	    die("No operator header found in $arg");
	}
	if ($line =~ /^([a-z ]*)operator[ \t]*([A-Za-z][A-Za-z0-9_]+)(.*)/) {
	    $op = $2;
	    $optable{$op} = "" if (!defined($optable{$op}));
	    @supers = ();
	    $line = $3;
	    @words = split(/\s+/,$line);
	    if (($word = &getword()) eq "extends") {
		$superop = &getword();
		push(@supers,$superop);
		$word = &getword();
	    }
	    if ($word eq "implements") {
		do {
		    $superop = &getword();
		    if ($superop =~ /^(.*),$/) {
			$superop = $1;
			$word = ",";
		    } else {
			$word = &getword();
		    }
		    # print ("Got superop $superop\n");
		    $superop = $typetable{$superop};
		    if ($superop) {
			# print "\nsuper for $op is $superop.\n";
			push(@supers,$superop);
		    }
		} while ($word eq ",");
	    }
	    die ("Missing { in $arg") if ($word ne "{");
	    $word = &getword();
	    if ($word eq "syntax") {
		$opsyntax{$op} = &getsyntax($op);
	    }
	    $opsupers{$op} = join (",",@supers);
	    foreach $superop (@supers) {
	        if ($superop ne $op) {
	    	    $opused{$superop} = "true";
		}
	    }
	    close(OPFILE);
	}
    }
}

# go through again, and announce each to its parent:
while (($op,$supers) = each %opsupers) {
    if ($allused || $opused{$op} || !defined($opsyntax{$op})) {
	$syntax = qq(<li><a href="#$op-syntax">$op</a>\n);
	if (defined($opsyntax{$op})) {
	    $optable{$op} .= $opsyntax{$op};
	}
    } else {
	$syntax = $opsyntax{$op};
    }
    foreach $superop (split(",",$supers)) {
	if ($op ne $superop) {
	    print "<!-- Super of $op is $superop -->\n";
	    $optable{$superop} .= $syntax;
	}
    }
}

open(HEADER,$header) || die("Could not open documentation header $header");
print STDOUT ("<BODY>\n");
print STDOUT <HEADER>;
print STDOUT ("<h2>Abstract Syntax (Improved)</h2>\n");
print STDOUT ("<dl>\n");
@grammar = ();
while (($op,$syntax) = each %optable) {
    if ($allused || $opused{$op}) {
        push (@grammar,
	      qq(<dt><a name="$op-syntax"></a>{\@link $package.$op}<dd>\n  <ul>$syntax</ul>\n));
    }
}
print STDOUT sort(@grammar);
print STDOUT ("</dl>\n");
print STDOUT ("</BODY>\n");

sub getsyntax {
    local($op,$syntax,$word,$donotomit,$lit) = @_;
    &getword();
    $syntax = "";
    until (($word = &getword()) eq "}") {
	if ($word eq "*" || $word eq "**" || $word eq "*/" || 
	    $word eq "+" || $word eq "++" || $word eq "+/" ||
	    $word eq "?" || $word eq "??" || $word eq "?/" ||
	    $word eq "(" || $word eq ")") {
	    $syntax .= "$word ";
	    if (length($word) == 2) {
		$donotomit = "true";
	    }
	} elsif ($word =~ /^<.*>$/) {
	    # not looked at
	    if ($donotomit) {
		$syntax .= "&lt;&gt; ";
		$donotomit = "";
	    }
	} elsif ($word =~ /^"(.*)"$/) {
	    $lit = $1;
	    $lit =~ s/&/&amp;/g;
	    $lit =~ s/</&lt;/g; 
	    $lit =~ s/>/&gt;/g;
	    $syntax .= "<tt>$lit</tt> ";
	    $donotomit = "";
	} elsif ($word =~ /^([a-zA-Z][A-Za-z0-9_]+:)?([A-Za-z][A-Za-z0-9_]+)(\([a-zA-Z0-9_]+\))?$/) {
	    $opused{$2} = "true";
	    $syntax .= qq(<a href="#$2-syntax">$2</a>);
	    if ($3 ne "") {
		$syntax .= "$3";
	    }
	    $syntax .= " ";
	    $donotomit = "";
	} elsif ($word =~ /^\$([a-zA-Z][A-Za-z0-9_]+:)?([A-Za-z][A-Za-z0-9_]+)$/) {
	    $syntax .= "\U$2 ";
	    $donotomit = "";
	} elsif (!($word =~ /^\"/)) {
	    die("bad syntax element $word");
	}
    }
    qq(<li>$syntax #{\@link $package.$op});
}

sub getword {
  if (@words == 0 || $words[0] =~ m|^//|) {
    $line = <OPFILE> || die ("operator file for $arg ended early");
    @words = split(/\s+/,$line);
    &getword;
  } elsif ($words[0] eq "") {
    shift @words;
    &getword;
  } else {
    shift @words;
  }
}


