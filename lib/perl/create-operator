#!/usr/local/bin/perl
# $Header: /cvs/fluid/fluid/lib/perl/create-operator,v 1.45 2006/01/11 21:07:25 chance Exp $

# Create Java files from operator description files.
# An operator description file is like a Java file with
# two differences: "operator" instead of "class"
# and a special declaration "syntax" that describes the
# structure of nodes with this operator.

$header = "";
$nodetype = "JJNode";
$create_method = "jjtCreate";
$optype = "Operator";
%typetable = ();
$debug = "false";
$unparse = "false";
$genvisitor = "false";
$isroot = "false";
$targetdir = ".";

# The following declarations parameterize the generation
# of the unparsing code.  It will need to be changed as the manner
# of unparsing is changed.
$unparse_name = "unparse";
$unparser_name = "unparser";
$unparse_type = "FmtStream";
$tokentype = "Token";
$create_keyword = "new Keyword(%s)";
$create_delim = "new Delim(%s)";
# the following strings are used with printf and a fixed set of
# parameters:
$unparse_child = "$unparser_name%0.0s.unparse(%s);\n";
$unparse_slot = "%s.unparse%s(node,$unparser_name);\n";
$unparse_literal = "%s.emit($unparser_name,node);\n";
$unparse_break = "%s.emit($unparser_name,node);\n";
$unparse_child_is_implicit = "$unparser_name.isImplicit(%s)";
$default_break = "<sp>";
$break_format = "$unparser_name.getStyle().get%s()";
# $breakformat = "BP%s";

while ($arg = shift) {
  if ($arg =~ /^-header=(.*)/) {
    $header = $1;
  } elsif ($arg =~ /^-nodetype=(.*)/) {
    $nodetype = $1;
  } elsif ($arg =~ /^-createmethod=(.*)/) {
    $create_method = $1;
  } elsif ($arg =~ /^-optype=(.*)/) {
    $optype = $1;
  } elsif ($arg =~ /^-unparsetype=(.*)/) {
    $unparse_type = $1;
  } elsif ($arg =~ /^-debug=(.*)/) {
    $debug = $1;
  } elsif ($arg =~ /^-unparse=(.*)/) {
    $unparse = $1;
  } elsif ($arg =~ /^-genvisitor=(.*)/) {
    $genvisitor = $1;
  } elsif ($arg =~ /^-breakformat=(.*)/) {
    $break_format = $1;
  } elsif ($arg =~ /^-defaultbreak=(.*)/) {
    $default_break = $1;
  } elsif ($arg =~ /^-target=(.*)/) {
    $targetdir = $1;
  } elsif ($arg =~ /^([A-Za-z]+):([A-Za-z]+)$/) {
    $typetable{$1} = $2;
  } elsif ($arg =~ /^(.*).java$/) { 
    $javafile = $arg;
  } elsif ($arg =~ /^(.*).op$/) {
    open(OPFILE,$arg) || die("Could not read operator file $arg");
    open(JAVAFILE,">$javafile") || die("Could not write Java file $javafile for $arg");
    # printf "Created $javafile";
    &printjava("// Generated from $arg.  Do *NOT* edit!\n");
    if ($header ne "") {
      open(HEADERFILE,$header) || die("Could not read header file $header");
      while ($line = <HEADERFILE>) {
        if (!($line =~ m/^#/)) {
	      &printjava($line);
        }
      }
      close(HEADERFILE);
    }
    &printjava("\@SuppressWarnings(\"all\")\n");
    
    while (($line = <OPFILE>) && !($line =~ /^[a-z ]*operator/)) {
      if (!($line =~ /^#/)) {
        &printjava($line);
      }
    }
    if ($line =~ /^([a-z ]*)operator[ \t]*([A-Za-z][A-Za-z0-9_]+)(.*)/) {
      $opname = $2;
      $line = $3;
      &printjava("$1class $opname ");
      @words = split(/\s+/,$line);
      if (($word = &getword()) eq "extends") {
        &printjava("extends ");
        $superop = &getword();
        $isroot = "false";        
	    &printjava("$superop ");
      } else {
        $isroot = "true";
        $superop = "";
        &printjava("extends $optype ");
        if ($word eq "implements") {
          &printjava("$word ");
          &printjava(" IAcceptor, ") if ($genvisitor eq "true");
        } else {
          &printjava("implements IAcceptor ") if ($genvisitor eq "true");
          &printjava("$word ");
        }
      }
      until ($word eq "{") {
	$word = &getword();
        &printjava("$word ");
      }
      &printjava("\n");
      &printjava("  protected $opname() {}\n\n");
      &printjava("  public static final $opname prototype = new $opname();\n\n");
      if ($superop ne "") {
   	    &printjava("  \@Override\n");
        &printjava("  public Operator superOperator() {\n");
     	&printjava("    return $superop.prototype;\n");
	    &printjava("  }\n\n");
      }
      if (($word = &getword("no echo")) eq "syntax") {
        &getword("no echo") eq "{" || die ("expected { in syntax");
	@syntax = ();
	@types = ();    # types for children and slots
	@precs = ();    # precedence for children (and slots?)
	@balance = ();	# "pointers" within syntax to matching ( )'s
	@open = ();	# stack of indices of unmatched left parens
	$total = 0;
	$children = 0;
	$slots = 0;
	$variable = "false";
	$variability = "";
	$variablechild = -1;
	$precedence = "false";
	until (($word = &getword("no echo")) eq "}") {
	  push(@syntax,$word);
	  push(@types,"");
	  push(@precs,"");
	  if ($word eq "*" || $word eq "**" || $word eq "*/" || 
              $word eq "+" || $word eq "++" || $word eq "+/") {
	    $variable = "true";
	    $variability = $word;
	  } elsif ($word eq "?" || $word eq "??" || $word eq "?/") {
	    ($variability =~ "[+]") || 
		die("? and ?/ only permitted for + variable syntax");
	    $variability = $word;
	  } elsif ($word eq "(") {
	    push(@open,$total+1);
	  } elsif ($word eq ")" ) {
	    if ($popped = pop(@open)) {
	      $popped -= 1;
	      $balance[$popped] = $total;
	      $balance[$total] = $popped;
	    } else {
	      die("unmatched right parenthesis");
	    }
	  } elsif ($word =~ /^<.*>$/) {
	    # not looked at currently
	  } elsif ($word =~ /^([a-zA-Z][A-Za-z0-9_]+:)?([A-Za-z][A-Za-z0-9_]+)(\([a-zA-Z0-9_]+\))?$/) {
	    if ($1 eq "") {
	      $syntax[$total] = "child$children";
	    } else {
	      $syntax[$total] = $1;
	      chop($syntax[$total]);
	    }
	    $types[$total] = $2;
	    $precs[$total] = $3;
	    if ($3 ne "") {
	      $precedence = "true";
	    }
	    $variablechild = $total;
	    $children += 1;
	  } elsif ($word =~ /^\$([a-zA-Z][A-Za-z0-9_]+:)?([A-Za-z][A-Za-z0-9_]+)$/) {
	    if ($1 eq "") {
	      $syntax[$total] = "\$slot$slots";
	    } else {
	      $syntax[$total] = "\$" . $1;
	      chop($syntax[$total]);
	    }
	    $types[$total] = $2;
	    $slots += 1;
	  } elsif (!($word =~ /^\"/)) {
	    die("bad syntax element $word");
	  }
	  $total += 1;
	}
	if (pop(@open)) {
	  die("unmatched left parenthesis");
	}
	# generate a routine that says it is a concrete production:
	&printjava("  \@Override\n");
	&printjava("  public boolean isProduction() {\n");
	&printjava("    return true;\n");
	&printjava("  }\n\n");

	if ($variable eq "true") {
	  if ($children < 1) {
	    die("'*' requires at least one child");
	  }
	  $child = $variablechild;
	  $variablechildtype = $types[$child];
	  $variablechildname = $syntax[$child];
	  $children -= 1;
	} else {
	  $variablechild = -1;
	}

#	  &printjava("  public Operator childOperator(int i) {\n");
#	  &printjava("    return $childtype.prototype;\n");
# 	  &printjava("  \@Override\n");	  
#         &printjava("  public Operator childOperator(IRLocation loc) {\n");
#	  &printjava("    return $childtype.prototype;\n");
#	  &printjava("  }\n\n");
#   	  &printjava("  \@Override\n");
#	  &printjava("  public String childLabel(int i) {\n");
#	  &printjava("    return \"$childname\";\n");
#	  &printjava("  }\n\n");	  
# 	  &printjava("  \@Override\n");
#	  &printjava("  public Operator variableOperator() {\n");
#	  &printjava("    return $childtype.prototype;\n");
#	  &printjava("  }\n\n");
#  	  &printjava("  \@Override\n");
#	  &printjava("  public int numChildren() {\n");
#	  &printjava("    return -$children;\n");
#          &printjava("  }\n\n");
#	  die("slots cannot be handled in sequence nodes, stopped")
#	      if ($slots != 0);
#	  #!! Should permit slots with sequence elements
#	  &printjava("  public static $nodetype " .
#		     "createNode(IRNode[] $childname) {\n");
#	  &printjava("    return new $nodetype(prototype,$childname);\n");
#	  &printjava("  }\n\n");
#
#	  &printjava("  public static $nodetype " .
#		     "createNode(SyntaxTreeInterface tree, IRNode[] $childname) {\n");
#	  &printjava("    return new $nodetype(tree, prototype,$childname);\n");
#	  &printjava("  }\n\n");
#	} else 
	{
	  # variable *or* fixed number of children
	  &printjava("  \@Override\n");
	  &printjava("  public Operator childOperator(int i) {\n");
	  if ($children == 0) {
	    if ($variable eq "true") {
	      &printjava("    return $variablechildtype.prototype;\n");
	    } else {
	      &printjava("    return null;\n");
	    }
	  } else {
	    &printjava("    switch (i) {\n");
	    $i = 0;
	    for ($child=0; $child < $total; $child += 1) {
	      $childname = $syntax[$child];
	      $childtype = $types[$child];
	      next if ($child == $variablechild);
	      if ($childname =~ /^[A-Za-z0-9_]*$/) {
		    &printjava("    case $i: return $childtype.prototype;\n");
		    $i += 1;
	      }
	    }
	    if ($variable eq "true") {
	      &printjava("    default: return $variablechildtype.prototype;\n");
	    } else {
	      &printjava("    default: return null;\n");
	    }
	    &printjava("    }\n");
	  }
	  &printjava("  }\n\n");

	  # efficient for special case
	  if ($variable eq "true" && $children == 0) {
	    &printjava("  \@Override\n");
	    &printjava("  public Operator childOperator(IRLocation loc) {\n");
	    &printjava("    return $variablechildtype.prototype;\n");
	    &printjava("  }\n\n");
	  }

   	  &printjava("  \@Override\n");
	  &printjava("  public String childLabel(int i) {\n");
	  if ($children == 0) {
	    if ($variable eq "true") {
	      &printjava("    return \"$variablechildname\";\n");
	    } else {
	      &printjava("    return \"\";\n");
	    }
	  } else {
	    &printjava("    switch (i) {\n");
	    $i = 0;
	    for ($child=0; $child < $total; $child += 1) {
	      $childname = $syntax[$child];
	      $childtype = $types[$child];
	      next if ($child == $variablechild);
	      if ($childname =~ /^[A-Za-z0-9_]*$/) {
		    &printjava("    case $i: return \"$childname\";\n");
  		    $i += 1;
	      }
	    }
	    if ($variable eq "true") {
	      &printjava("    default: return \"$variablechildname\";\n");
	    } else {
	      &printjava("    default: return \"\";\n");
	    }
	    &printjava("    }\n");
	  }
	  &printjava("  }\n\n");
	  
	  &printjava("  \@Override\n");
	  &printjava("  public String infoType(int i) {\n");
	  if ($slots == 0) {
	    &printjava("    return \"\";\n");
	  } else {
	    &printjava("    switch (i) {\n");
	    $i = 0;
	    for ($child=0; $child < $total; $child += 1) {
	      $childname = $syntax[$child];
	      $childtype = $types[$child];
   	      if ($childname =~ /^\$(.*)/) {
		    &printjava("    case $i: return \"$childtype\";\n");
  		    $i += 1;
	      }
	    }
	    &printjava("    default: return \"\";\n");
	    &printjava("    }\n");
	  }
	  &printjava("  }\n\n");

	  &printjava("  \@Override\n");
	  &printjava("  public String infoLabel(int i) {\n");
	  if ($slots == 0) {
	    &printjava("    return \"\";\n");
	  } else {
	    $i = 0;
	    &printjava("    switch (i) {\n");
	    for ($child=0; $child < $total; $child += 1) {
	      $childname = $syntax[$child];
	      $childtype = $types[$child];
   	      if ($childname =~ /^\$(.*)/) {
		    &printjava("    case $i: return \"$childname\";\n");
  		    $i += 1;
	      }
	    }
	    &printjava("    default: return \"\";\n");
	    &printjava("    }\n");
	  }
	  &printjava("  }\n\n");
	  
	  if ($variable eq "true") {
	    &printjava("  public Operator variableOperator() {\n");
	    &printjava("    return $variablechildtype.prototype;\n");
	    &printjava("  }\n\n");
	  }

	  &printjava("  \@Override\n");
	  &printjava("  public int numInfo() {\n");
	  &printjava("    return $slots;\n");
	  &printjava("  }\n\n");	  
	  
	  &printjava("  \@Override\n");
	  &printjava("  public int numChildren() {\n");
	  if ($variable eq "true") {
	    $tmp = $children+1;
	    &printjava("    return -$tmp;\n");
	  } else {
	    &printjava("    return $children;\n");
	  }
	  &printjava("  }\n\n");
	  # generate creation routine
	  if ($children != 0 || $slots != 0 || $variable eq "true") {
	    &printjava("  public static $nodetype createNode(");
	    $spaces = $nodetype;
	    $spaces =~ tr// /c;
	    $j=0;
	    $first = "true";
	    while ($j < @syntax) {
	      if ($syntax[$j] =~ /^\$(.*)/) {
		$childname = $1;
		$childtype = $typetable{$types[$j]};
		if ($childtype eq "") {
		  $childtype = "Object";
		}
		if ($first ne "true") {
		  &printjava(",\n                $spaces            ");
		}
		$first = "false";
		&printjava("$childtype $childname");
	      } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		$childname = $syntax[$j];
		if ($first ne "true") {
		  &printjava(",\n                $spaces            ");
		}
		$first = "false";
		&printjava("IRNode $childname");
		if ($j == $variablechild) {
		  &printjava("[]");
		}
	      }
	      $j+=1;
	    }
	    &printjava(") {\n");
	    &printjava("    return createNode(tree");
	    $i=0; $j=0; $first="false";
	    while ($j < @syntax) {
		if ($syntax[$j] =~ /^\$(.*)/) {
		    &printjava(", $1"); # childname
		    $i += 1;
		} elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		    $childname = $syntax[$j];
		    &printjava(", $childname");
		    $i += 1;
		}
		$j+=1;
	    }	  
	    &printjava(");\n");
	    &printjava("  }\n");

	    &printjava("  public static $nodetype createNode(SyntaxTreeInterface tree, ");
	    $spaces = $nodetype;
	    $spaces =~ tr// /c;
	    $j=0;
	    $first = "true";
	    while ($j < @syntax) {
	      if ($syntax[$j] =~ /^\$(.*)/) {
		$childname = $1;
		$childtype = $typetable{$types[$j]};
		if ($childtype eq "") {
		  $childtype = "Object";
		}
		if ($first ne "true") {
		  &printjava(",\n                $spaces            ");
		}
		$first = "false";
		&printjava("$childtype $childname");
	      } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		$childname = $syntax[$j];
		if ($first ne "true") {
		  &printjava(",\n                $spaces            ");
		}
		$first = "false";
		&printjava("IRNode $childname");
		if ($j == $variablechild) {
		  &printjava("[]");
		}
	      }
	      $j+=1;
	    }
	    &printjava(") {\n");
	    if ($children == 0 && $variable ne "true") {
	      &printjava("    $nodetype _result = new $nodetype(tree, prototype);\n");
	    } elsif ($children == 0 && $variable eq "true") {
	      &printjava("    $nodetype _result = new $nodetype(tree, prototype,$variablechildname);\n");
	    } elsif ($variable ne "true") {
		&printjava("    $nodetype _result = new $nodetype(tree, prototype,".
			   " new IRNode[]{");
		$i=0; $j=0; $first="true";
		while ($j < @syntax) {
		    if ($syntax[$j] =~ /^\$(.*)/) {
			0;
		    } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
			$childname = $syntax[$j];
			if ($first eq "true") {
			    $first = "false";
			} else {
			    &printjava(",");
			}
			&printjava("$childname");
			$i += 1;
		    }
		    $j+=1;
		}	  
		&printjava("});\n");
	      } else {
		# variable *and* more children.
		&printjava("    IRNode[] _children = new IRNode[$children+$variablechildname.length];\n");
		$i=0; $j=0;
		for ($j=0; $j < @syntax; ++$j) {
		    next if ($j == $variablechild);
		    if ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
			$childname = $syntax[$j];
			&printjava("    _children[$i] = $childname;\n");
			$i += 1;
		    }
		}	
		&printjava("    for (int _i=0; _i < $variablechildname.length; ++_i) {\n");
		&printjava("      _children[$children+_i] = $variablechildname [_i];\n");
		&printjava("    }\n");
		&printjava("    $nodetype _result = new $nodetype(tree, prototype, _children);\n");
	      }
	    $i=0; $j=0;
	    while ($j < @syntax) {
	      if ($syntax[$j] =~ /^\$(.*)/) {
		$childname = $1;
		$childtype = $types[$j];
		&printjava("    $nodetype.set\u$childtype(_result,$childname);\n");
	      } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		$i += 1;
	      }
	      $j+=1;
	    }	  
	    &printjava("    return _result;\n");
	    &printjava("  }\n\n");
	  }
	  if ($slots != 0) {
	    # generate check routine
	    &printjava("  \@Override\n");
	    &printjava("  public boolean isComplete(IRNode node) {\n");
	    &printjava("    if (!super.isComplete(node)) return false;\n");
	    &printjava("    try {\n");
	    for ($child=0; $child < $total; $child += 1) {
		$childname = $syntax[$child];
		next unless ($childname =~ /^\$/);

		$childtype = $types[$child];
		&printjava("      $nodetype.get\u$childtype(node);\n");
	    }
	    &printjava("    } catch (SlotUndefinedException ex) {\n");
	    &printjava("      return false;\n");
	    &printjava("    }\n");
	    &printjava("    return true;\n");
	    &printjava("  }\n\n");
	    
	    # generate copy routine
	    &printjava("  \@Override\n");
	    &printjava("  public IRNode copyTree(IRNode node) {\n");
	    &printjava("    IRNode _result = super.copyTree(node);\n");
	    $i=0; $j=0;
	    while ($j < @syntax) {
	      if ($syntax[$j] =~ /^\$(.*)/) {
		$childname = $1;
		$childtype = $types[$j];
		&printjava("    $nodetype.set\u$childtype(_result,$nodetype.get\u$childtype(node));\n");
	      } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		$i += 1;
	      }
	      $j+=1;
	    }	  
	    &printjava("    return _result;\n");
	    &printjava("  }\n\n");

	    # generate local compare routine
	    &printjava("  \@Override\n");   
	    &printjava("  public boolean isEquivalentNode(IRNode n1, IRNode n2) {\n");
	    &printjava("    return super.isEquivalentNode(n1, n2) &&\n");
	    $i=0; $j=0;
	    while ($j < @syntax) {
	      if ($syntax[$j] =~ /^\$(.*)/) {
		$childname = $1;
		$childtype = $types[$j];
		&printjava("           ($nodetype.get\u$childtype(n1) == $nodetype.get\u$childtype(n2)) &&\n");
	      } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
		$i += 1;
	      }
	      $j+=1;
	    }	  
	    &printjava("    true;\n");
	    &printjava("  }\n\n");
	  }
	}
	# generate access routines
	$i=0; $j=0;
	# Someone made the access check only happen
	# if logging is on.  This is a mistake. --JTB
        $accesscheck = 
            # "    if (LOG.isLoggable(Level.INFO)) {\n" . 
            "    Operator op = tree.getOperator(node);\n" .
            "    if (!(op instanceof $opname)) {\n" .
            "      throw new IllegalArgumentException(\"node not $opname: \"+op);\n" .
            "    }\n"
            #. "    }\n"
		;

	while ($j < @syntax) {
	  if ($syntax[$j] =~ /^\$(.*)/) {
	    $childname = $1;
	    $childtype = $types[$j];
	    $childjavatype = $typetable{$childtype};
	    if ($childjavatype eq "") {
	      $childjavatype = "Object";
	    }
	    &printjava("  public static $childjavatype get\u$childname(IRNode node) {\n");
	    &printjava($accesscheck);
	    &printjava("    return $nodetype.get\u$childtype(node);\n");
	    &printjava("  }\n\n");
	  } elsif ($syntax[$j] =~ /^[A-Za-z0-9_]*$/) {
	    $childname = $syntax[$j];
	    $childtype = $types[$j];
	    $childjavatype = $typetable{$childtype};
	    if ($childjavatype eq "") {
	      $childjavatype = $childtype;
	    }
	    if ($variablechild == $j) {
	      &printjava("  public static IRNode get\u$childname(IRNode node, int i) {\n");
	      &printjava("    return get\u$childname(tree, node, i);\n");
	      &printjava("  }\n\n");
	      &printjava("  public static Iteratable<IRNode> get\u${childname}Iterator(IRNode node) {\n");
	      &printjava("    return get\u${childname}Iterator(tree, node);\n");
	      &printjava("  }\n\n");

	      &printjava("  public static IRNode get\u$childname(SyntaxTreeInterface tree, IRNode node, int i) {\n");
	      &printjava($accesscheck);
	      &printjava("    return tree.getChild(node,$children+i);\n");
	      &printjava("  }\n\n");
	      &printjava("  public static Iteratable<IRNode> get\u${childname}Iterator(SyntaxTreeInterface tree, IRNode node) {\n");
	      &printjava($accesscheck);
	      &printjava("    Iteratable<IRNode> _result = tree.children(node);\n");
	      for ($i=0; $i < $children; ++$i) {
	        &printjava("    _result.next(); // discard prefix\n");
	      }
	      &printjava("    return _result;\n");
	      &printjava("  }\n\n");
	    } else {
	      &printjava("  public static final int ${childname}Loc = $i;\n");
	      &printjava("  public static final IRLocation ${childname}Location = IRLocation.get($i);\n\n");
	      
	      &printjava("  public static IRNode get\u$childname(IRNode node) {\n");
	      &printjava("    return get\u$childname(tree, node);\n");
	      &printjava("  }\n\n");

	      &printjava("  public static IRNode get\u$childname(SyntaxTreeInterface tree, IRNode node) {\n");
	      &printjava($accesscheck);
	      &printjava("    return tree.getChild(node,$i);\n");
	      &printjava("  }\n\n");
	      
	      &printjava("  public static void set\u$childname(IRNode node, IRNode ch) {\n");
	      &printjava("    set\u$childname(tree, node, ch);\n");
	      &printjava("  }\n\n");

	      &printjava("  public static void set\u$childname(SyntaxTreeInterface tree, IRNode node, IRNode ch) {\n");
	      &printjava($accesscheck);
	      &printjava("    tree.setChild(node,$i,ch);\n");
	      &printjava("  }\n\n");
	    }
	    $i += 1;
	  }
	  $j+=1;
	}
	# generate unparsing
	if ($unparse eq "true") {
	  # generate tokens for literals:
	  $j=0; $keyword=0;
	  while ($j < @syntax) {
	    $element = $syntax[$j];
	    if ($element =~ /^\"/) {
	      $keyword += 1;
              &printjava("  private static $tokentype littoken$keyword = ");
              if ($element =~ /^\"[a-zA-Z]+/) {
	        &printfjava($create_keyword,$element);
              } else {
	        &printfjava($create_delim,$element);
              }
	      &printjava(";\n");
            }
	    $j += 1;
          }
	  if ($keyword > 0) {
	    &printjava("\n");
	  }
	  if (@syntax == 0) {
	      &printjava("  public void $unparse_name" .
			 "Wrapper(IRNode node, $unparse_type $unparser_name) {\n");
	      &printjava("  }\n\n");
	  } elsif ($variable eq "true" && &empty_yield_possible(0,@syntax-1)) {
	      &printjava("  public void $unparse_name" .
			 "Wrapper(IRNode node, $unparse_type $unparser_name) {\n");
	      &printjava("    if ($unparser_name.getTree().numChildren(node) > 0) super.$unparse_name" .
			 "Wrapper(node,$unparser_name);\n");
	      &printjava("  }\n\n");
	  }
	  &printjava("  \@Override public void $unparse_name" .
		     "(IRNode node, $unparse_type $unparser_name) {\n");

	  &printjava("    SyntaxTreeInterface tree = $unparser_name.getTree();\n");
	  &printjava($accesscheck);

          if ($variable eq "true") {
            &printjava("    Iteratable<IRNode> e = tree.children(node);\n");
          }
          $j=0; $i=0; $keyword=0;
	  # $broke = "true";
          $indent = "    ";
          while ($j < @syntax) {
            $element = $syntax[$j];
            $nextj = $j+1;
            if ($element eq "(") {
              $nextj = $balance[$j]+1;
            }
	    $lastj = $j-1;
	    if ($element eq ")") {
	      $lastj = $balance[$j]-1;
	    }
            # determine whether the element is to be looped over:
            if ($element ne ")" && $syntax[$nextj] =~ /^[+*]/) {
	      &printjava($indent,"while (e.hasNext()) {\n");
              $indent .= "  ";
            } elsif ($element ne ")" && $syntax[$nextj] =~ /^[?]/) {
	      &printjava($indent,"if (e.hasNext()) {\n");
	      $indent .= "  ";
	    }
	    if ($element =~ /^\$(.*)/) {
	      # if ($broke ne "true" && $default_break =~ /^<(.+)>$/) {
	      #   &printbreak($indent,$1);
	      # }
              &printjava($indent);
              &printfjava($unparse_slot,$nodetype,$types[$j]);
	      # $broke = "false";
            } elsif ($element =~ /^[A-Za-z0-9_]+$/) {
	      # if ($broke ne "true" && $default_break =~ /^<(.+)>$/) {
	      #   &printbreak($indent,$1);
	      # }
	      &printjava($indent);
              if ($variable eq "true") {
                &printfjava($unparse_child,$nodetype,"e.next()");
              } else {
                &printfjava($unparse_child,$nodetype,"tree.getChild(node,$i)");
                $i += 1;
              }
	      # $broke = "false"
            } elsif ($element =~ /^\"/) {
	      # if ($broke ne "true" && $default_break =~ /^<(.+)>$/) {
	      #   &printbreak($indent,$1);
	      # }
              $kind = $delimiters{substr($element,1,1)};
              &printjava($indent);
	      $keyword += 1;
	      &printfjava($unparse_literal,"littoken$keyword");
	      # $broke = "false";
            } elsif ($element =~ /^<(.*)>$/) {
              # special case for implicit markers: <?> </?>
              if ($1 eq "?") {
                if ($variable eq "true") {
                  die("cannot use <?> </?> in variable lists (missing feature)");
                }
                &printjava($indent,"if (!");
                &printfjava($unparse_child_is_implicit,"tree.getChild(node,$i)");
                &printjava(") {\n");
                $indent .= "  ";
              } elsif ($1 eq "/?") {
                $indent = substr($indent,2);
	            &printjava($indent,"}\n");
	          } else {
	            &printbreak($indent,$1);
	          }
	      # $broke = "true";
	    } elsif ($element =~ /^[*+]./) {
	      &printjava($indent,"if (!e.hasNext()) break;\n");
	    } elsif ($element =~ /^[?]./) {
	      $indent = substr($indent,2);
	      &printjava($indent,"} else {\n");
	      $indent .= "  ";
	    }
            # are we ending a loop or an if?
            if ($element =~ /^[+*]$/ ||
		($element ne "(" && $syntax[$lastj] =~ /^[+*]./)) {
	      $indent = substr($indent,2);
	      &printjava($indent,"}\n"); # end while
	    } elsif ($element =~ /^[?]$/ ||
		     ($element ne "(" && $syntax[$lastj] =~ /^[?]./)) {
	      $indent = substr($indent,2);
	      &printjava($indent,"}\n");
	    }
	    $j += 1;
	  }
          if ($indent ne "    ") {
	    die("got confused in unparsing");
          }
	  &printjava("  }\n\n");

	  #create isMissingTokens function
	  &printjava("  \@Override\n");
	  &printjava("  public boolean isMissingTokens(IRNode node)  {\n");
	  if (@syntax == 0) {
	      &printjava("    return false;\n");
	      &printjava("  }\n\n");
	  } elsif ($variable eq "true" && &empty_yield_possible(0,@syntax - 1)) {
	      &printjava("    if (JavaNode.tree.numChildren(node) > 0) return true;\n");
	      &printjava("    else return false;\n");
	      &printjava("  }\n\n");
	  } else {
	      &printjava("    return true;\n");
	      &printjava("  }\n\n");
	  }
	  #create missingTokens function
	  # JTB: Not sure what this is: bit rot alert!
      &printjava("  \@Override\n");	    
	  &printjava("  public Vector<Token>[] missingTokens(IRNode node) {\n");
	  &printjava("    SyntaxTreeInterface tree = JavaNode.tree;\n");
	  &printjava($accesscheck);
	  if ($variable eq "true") {
	      &printjava("    Iteratable<IRNode> e = tree.children(node);\n");
	      &printjava("    int i = 0;\n");
	  }
	  &printjava("    int numChildren = tree.numChildren(node);\n");
	  #&printjava("    if ((index < 0) || (index > numChildren))\n");
	  #&printjava("       throw new IllegalArgumentException(\"index is out of bound.\");\n");
	  &printjava("    Vector<Token>[] TokenList = (Vector<Token>[]) new Vector[numChildren+1];\n");
	  &printjava("    for (int j = 0; j < numChildren + 1; j++)\n");
	  &printjava("       TokenList[j] = new Vector<Token>();\n");
	  $j = 0; $i = 0; $keyword = 0;
	  $indent = "    ";
	  while ($j < @syntax) {
	    $element = $syntax[$j];
	    $nextj = $j + 1;
	    if ($element eq "(") {
		  $nextj = $balance[$j] + 1;
	    }
	    $lastj = $j - 1;
	    if ($element eq ")") {
		  $lastj = $balance[$j] - 1;
	    }
	    if ($element ne ")" && $syntax[$nextj] =~ /^[+*]/) {
		  &printjava($indent,"while (e.hasNext()) {\n");
		  $indent .= "  ";
	    } elsif ($element ne ")" && $syntax[$nextj] =~ /^[?]/) {
		  &printjava($indent,"if (e.hasNext()) {\n");
		  $indent .= "  ";
	    }
	    if ($element =~ /^\$(.*)/) {
		  &printjava($indent);
		  if ($types[$j] eq "Modifiers") {
		    if ($variable eq "true") {
			  &printjava("Token[] tl = JavaNode.getModiferTokens(node);\n");
			  &printjava($indent,"if (tl != null && tl.length > 0)\n");
			  &printjava($indent,"  for (int j = 0; j < tl.length; j++)\n");
			  &printjava($indent,"    TokenList[i].add(tl[j]);\n");
		    } else {
			  &printjava("Token[] tl = JavaNode.getModiferTokens(node);\n");
			  &printjava($indent,"if (tl != null && tl.length > 0)\n");
              &printjava($indent,"  for (int j = 0; j < tl.length; j++)\n");
              &printjava($indent,"    TokenList[$i].add(tl[j]);\n");
		    }
		  } elsif ($types[$j] eq "Info") {
		      if ($variable eq "true") {
			    &printjava("Identifier id = new Identifier(JavaNode.getInfo(node).toString());\n");
			    &printjava($indent,"TokenList[i].add(id);\n");
		      } else {
			    &printjava("Identifier id = new Identifier(JavaNode.getInfo(node).toString());\n");
                &printjava($indent,"TokenList[$i].add(id);\n");
		      }
		  } elsif ($types[$j] eq "Op") {
		      if ($variable eq "true") {
			    &printjava("TokenList[i].add(JavaNode.getOp(node).asToken());\n");
		      } else {
			    &printjava("TokenList[$i].add(JavaNode.getOp(node).asToken());\n"); 
		      }
		  } elsif ($types[$j] eq "Code") {
              if ($variable eq "true") {
                &printjava("TokenList[i].add(new Keyword(\"<compiled>\"));\n");
              } else {
                &printjava("TokenList[$i].add(new Keyword(\"<compiled>\"));\n");
              }
		  } elsif ($types[$j] eq "DimInfo") {
		      if ($variable eq "true") {
		      	&printjava("Token tok = JavaNode.getDimToken(node);\n");
				&printjava($indent,"if (tok != null)\n");
                &printjava($indent,"  TokenList[i].add(tok);\n");
              } else {
                &printjava("Token tok = JavaNode.getDimToken(node);\n");
				&printjava($indent,"if (tok != null)\n");
                &printjava($indent,"  TokenList[$i].add(tok);\n");
              }
		  }
	    } elsif ($element =~ /^[A-Za-z-0-9_]+$/) {
		  &printjava($indent);
		  if ($variable eq "true") {
		    &printjava("e.next();\n");
		    &printjava($indent,"i++;\n");
		  } else {
		    &printjava("tree.getChild(node,$i);\n");
		    $i += 1;
		  }
	    } elsif ($element =~ /^\"/) {
		  # $kind = $delimiters(substr($element,1,1));
		  &printjava($indent);
		  $keyword += 1;
		  if ($variable eq "true") {
            &printjava("TokenList[i].add(littoken$keyword);\n");
          } else {
		    &printjava("TokenList[$i].add(littoken$keyword);\n");
		  }
	    } elsif ($element =~ /^<(.*)>$/) {
	    } elsif ($element =~ /^[*+]./) {
		    &printjava($indent,"if (!e.hasNext()) break;\n");
	    } elsif ($element =~ /^[?]./) {
		    $indent = substr($indent,2);
		    &printjava($indent,"} else {\n");
		    $indent .= "  ";
	    }
	    if ($element =~ /^[+*]$/ ||
		  ($element ne "(" && $syntax[$lastj] =~ /^[+*]./)) {
		  $indent = substr($indent,2);
		  &printjava($indent,"}\n"); # end while
	    } elsif ($element =~ /^[?]$/ ||
		  ($element ne "(" && $syntax[$lastj] =~ /^[?]./)) {
		    $indent = substr($indent,2);
            &printjava($indent,"}\n");
	    }
	    $j += 1;
	  }
	  #&printjava("    int size = TokenList[index].size();\n");
	  #&printjava("    if (size == 0) return null;\n");
	  #&printjava("    Token[] toks = new Token[size];\n");
	  #&printjava("    toks = (Token[]) TokenList[index].toArray(toks);\n");
	  #&printjava("    return toks;\n");
	  &printjava("    return TokenList;\n");
	  &printjava("  }\n\n");

	  if ($keyword > 0) {
    	&printjava("  \@Override\n");
	    &printjava("  public Token asToken() {\n");
	    &printjava("    return littoken1;\n");
	    &printjava("  }\n\n");
	  }
	}
	if ($precedence eq "true") {
	  if ($variable eq "true") {
	    $childprec = $precs[$variablechild];
	    &printjava("  \@Override\n");	    
	    &printjava("  public int childPrecedence(int i) {\n");
	    &printjava("    return $childprec;\n");
	    &printjava("  }\n\n");
	    &printjava("  \@Override\n");	    
  	    &printjava("  public int childPrecedence(IRLocation loc) {\n");
	    &printjava("    return $childprec;\n");
	    &printjava("  }\n\n");
	  } else {
	    &printjava("  \@Override\n");	    	  
	    &printjava("  public int childPrecedence(int i) {\n");
	    &printjava("    switch (i) {\n");
	    $i = 0;
	    for ($child=0; $child < $total; $child += 1) {
	      $childprec = $precs[$child];
	      if ($childprec =~ /^\((.*)\)$/) {
		&printjava("    case $i: return $1;\n");
	      }
	      if ($syntax[$child] =~ /^[A-Za-z0-9_]+$/) {
		$i += 1;
	      }
	    }
	    &printjava("    default: return 0;\n");
	    &printjava("    }\n");
	    &printjava("  }\n\n");
	  }
	}
    &printaccept();
    } else {
    &printaccept();
	if ($word ne "}") {
	  &printjava("\n");
	}
        &printjava($line);
      }
      while ($line = <OPFILE>) {
        &printjava($line);
      }
    }
    close(JAVAFILE);
    $realjavafile = $javafile;
    chop($realjavafile);
    unlink($realjavafile);
    rename($javafile,$realjavafile) || die ("Could not create $realjavafile");
  }
}

sub printaccept {
	if ($genvisitor eq "true") {
	  if ($isroot eq "false") {
  	    &printjava("  \@Override\n");
  	  }
	  &printjava("  public <T> T accept(IRNode node, IVisitor<T> visitor) {\n");
	  &printjava("    return visitor.visit$opname(node);\n");
	  &printjava("  }\n\n");
	}
}

sub boxify {
    local ($type,$code) = @_;
    if ($type eq "int") {
	return "fluid.util.IntegerTable.newInteger($code)";
    } elsif ($type eq "boolean") {
	return "($code)?Boolean.TRUE:Boolean.FALSE";
    } else {
	return $code;
    }
}

sub unboxify {
    local ($type,$code) = @_;
    if ($type eq "int") {
	return "((Integer)$code).intValue()";
    } elsif ($type eq "boolean") {
	return "((Boolean)$code).booleanValue()";
    } else {
	return "($type)$code";
    }
}

sub empty_yield_possible {
    local ($start,$stop) = @_;
    # check for X ? and X *
    if ($syntax[$stop] eq "*" || $syntax[$stop] eq "?") {
	return ($start+1 == $stop ||
		($syntax[$start] eq "(" && $balance[$start]+1 == $stop));
    }
    # check for X ** Y
    $start = $balance[$start] if ($syntax[$start] eq "(");
    ++$start;
    return 0 if ($syntax[$start] ne "**");
    ++$start;
    $start = $balance[$start] if ($syntax[$start] eq "(");
    return ($start == $stop);
}

sub getword {
  if (@words == 0 || $words[0] =~ m|^//|) {
    $line = <OPFILE> || die ("operator file ended early");
    (@_ == 0) && &printjava("\n    ");
    @words = split(/\s+/,$line);
    &getword;
  } elsif ($words[0] eq "") {
    shift @words;
    &getword;
  } else {
    shift @words;
  }
}

sub printbreak {
  $indent = $_[0];
  $name = $_[1];
  if ($name eq "") {
    $name = "none";
  }
  &printjava($indent);
  if ($name =~ m|^/(.*)|) {
    $name = "end" . $1;
  }
  &printfjava($unparse_break,sprintf($break_format, "\U$name"));
}

sub printjava {
  print JAVAFILE (@_);
  if ($debug eq "true") {
    print (@_);
  }
}

sub printfjava {
  printf JAVAFILE (@_);
  if ($debug eq "true") {
    printf (@_);
  }
}
