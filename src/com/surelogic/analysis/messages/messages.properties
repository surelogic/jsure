#Color second pass messages
ColorSecondPass_inferredColor=Inferred @colorConstraint {0} for {1}
ColorSecondPass_inheritedColor=Inherited @colorConstraint {0} for {1}
ColorSecondPass_inheritedTransparent=Inherited @transparent for {0}
ColorSecondPass_colorContextDrop={0} is accessed from color context {1}

#Thread effect analysis messagse
ThreadEffectsAnalysis_noThreadsDrop=No threads started within {0}
ThreadEffectsAnalysis_threadEffectDrop=Thread effect declaration prohibits: {0}
ThreadEffectsAnalysis_callPromiseDrop=Call " {0} " promises to start nothing
ThreadEffectsAnalysis_callNotPromiseDrop=Call " {0} " has not promised to start nothing

#Lock visitor messages

## Drop-sea category messages
LockAnalysis_dsc_AggregationNeeded=protected reference(s) to a possibly shared unprotected object; possible race condition detected
LockAnalysis_dsc_FieldAccessNotAssured=unprotected field access(es); possible race condition detected
LockAnalysis_dsc_FieldAccessAssured=protected field access(es)
LockAnalysis_dsc_PreconditionsAssured=lock precondition(s) satisfied
LockAnalysis_dsc_PreconditionsNotAssured=lock precondition(s) not satisfied; possible race conditions enabled
LockAnalysis_dsc_IndirectFieldAccessNotAssured=unprotected indirect field access(es); possible race condition detected
LockAnalysis_dsc_IndirectFieldAccessAssured=protected indirect field access(es)
LockAnalysis_dsc_ReturnAssured=return statement(s) returning the correct lock
LockAnalysis_dsc_ReturnNotAssured=return statement(s) possibly returning the wrong lock
LockAnalysis_dsc_UnidentifiableLockWarning=unidentifiable lock(s); what is the name of the lock? what state is being protected?
LockAnalysis_dsc_SynchronizationUnusedWarning=synchronized block(s) not protecting any state; what state is being protected?
LockAnalysis_dsc_NonfinalExpressionWarning=non-final lock expression(s); analysis cannot determine which lock is being acquired
LockAnalysis_dsc_RedundantSynchronized=redundant lock acquisition(s)
LockAnalysis_dsc_MixedParadigm=mixed java.util.concurrent/intrinsic locking usage(s)
LockAnalysis_dsc_NotALockMethod=calls to methods masquerading as java.util.concurrent.Lock methods
LockAnalysis_dsc_MatchingCalls=lock()\u2013unlock() matches

## Drop-sea result messages
LockAnalysis_ds_SynchronizedConstructorAssured=singleThreaded constructor supported
LockAnalysis_ds_SynchronizedConstructorNotAssured=singleThreaded constructor has possibly escaping receiver
LockAnalysis_ds_AggregationNeeded=Field reference \"{0}\" may be to a shared unprotected object
LockAnalysis_ds_AggregationNeeded2=Receiver \"{0}\" may be a shared unprotected object
LockAnalysis_ds_FieldAccessAssured=Lock \"{0}\" held when accessing {1}
LockAnalysis_ds_FieldAccessNotAssured=Lock \"{0}\" not held when accessing {1}
LockAnalysis_ds_PreconditionsAssured=Lock \"{0}\" held when invoking {1}
LockAnalysis_ds_PreconditionsNotAssured=Lock \"{0}\" not held when invoking {1}
LockAnalysis_ds_IndirectFieldAccessAssured=Lock \"{0}\" held when invoking {1}
LockAnalysis_ds_IndirectFieldAccessNotAssured=Lock \"{0}\" not held when invoking {1}
LockAnalysis_ds_ReturnAssured=Return statement correctly returns lock \"{0}\"
LockAnalysis_ds_ReturnNotAssured=Return statement expected to return lock \"{0}\"
LockAnalysis_ds_SynchronizedMethodWarningDetails=Synchronized method {0}: \"this\" is not identifiable as a programmer-declared lock
LockAnalysis_ds_SynchronizedStaticMethodWarningDetails=Synchronized method {0}: \"{1}.class\" is not identifiable as a programmer-declared lock
LockAnalysis_ds_SynchronizationUnused=Locks {0} not needed by body of synchronized block
LockAnalysis_ds_NonfinalExpression=Lock expression \"{0}\" is not final
LockAnalysis_ds_UnidentifiableLock=Synchronized block: Lock expression \"{0}\" is not identifiable as a programmer-declared lock
LockAnalysis_ds_RedundantSynchronized=Acquisition of lock \"{0}\" may be redundant
LockAnalysis_ds_SyncedJUCLock=Using a java.util.concurrent.locks lock object \"{0}\" in a syncronized statement
LockAnalysis_ds_MasqueradingCall=\"{0}\" does not call a method from java.util.concurrent.Lock
LockAnalysis_ds_MasqueradingCall2=\"{0}\" does not call a method from java.util.concurrent.ReadWriteLock
LockAnalysis_ds_PoisonedLockCall="{0}() call has a different number of matching unlock() calls along different control paths"
LockAnalysis_ds_NoMatchingUnlocks="{0}() call has no matching unlock() calls"
LockAnalysis_ds_MatchingUnlock="{0}() call has matching unlock() call at line {1}"
LockAnalysis_ds_PoisonedUnlockCall="unlock() call has a different number of matching lock() calls along different control paths"
LockAnalysis_ds_NoMatchingLocks="unlock() call has no matching lock() calls"
LockAnalysis_ds_MatchingLock="unlock() call has matching {0}() call at line {1}"

## Drop-sea Supporting information messages 
LockAnalysis_ds_OnBehalfOfConstructor=Analyzed on behalf of constructor \"{0}\"
LockAnalysis_ds_FieldDeclaration=Field Declaration: {0}
LockAnalysis_ds_HeldLock=Intrinsic lock \"{0}\" is held
LockAnalysis_ds_HeldJUCLock=java.util.concurrent lock \"{0}\" is held
