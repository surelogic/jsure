package edu.cmu.cs.fluid.java.analysis;

import edu.cmu.cs.fluid.ir.IRNode;

public interface IAliasAnalysis {
  /**
   * Interface describing a method that abstracts the specific kind of 
   * alias analysis, may vs. must, being performed, and encapsulates the 
   * <em>location</em> in the code at which the alias comparison is
   * performed.
   * 
   * <p>Instances of this interface are generated by the methods
   * {@link IAliasAnalysis#getMustAliasMethod} and
   * {@link IAliasAnalysis#getMayAliasMethod}.
   */
  public interface Method {
    /**
     * Return true if the two expressions alias each other at the program point
     * indicated.
     * 
     * @param expr1
     *          a side-effect-free expression with correct binding information
     *          that would be legal at the execution point indicated. It need not
     *          be an expression in context.
     * @param expr2
     *          same as expr1
     */
    public boolean aliases(IRNode expr1, IRNode expr2);
  }

  
  
  /**
   * Class that partially generates {@link Method} objects tailored to a 
   * specific location.  The location is specific by the <code>before</code>
   * arguments to the methods {@link #getMayAliasMethod(IRNode)} and
   * {@link #getMustAliasMethod(IRNode)}.
   * 
   * <p>In turn, this object is obtained by calling {@link #getMethodFactory(IRNode}},
   * which returns a method factory equipped to return Method objects whose
   * focused location is within a particular flow unit.
   */
  public interface MethodFactory {
    public Method getMayAliasMethod(IRNode before);
    
    public Method getMustAliasMethod(IRNode before);
  }
  
  
  
  /**
   * Get a method factory suitable for focusing on nodes in the given
   * flow unit.  
   */
  public MethodFactory getMethodFactory(IRNode flowUnit);
  
  
  
  /**
   * Return true if the two expressions alias each other at the program point
   * indicated. This means they possibly evaluate to the same non-null
   * reference.  
   * 
   * <p>This method is not a preferred entry into the alias analysis.  If multiple
   * queries are desired, it is probably more efficient to obtain a 
   * {@link Method} object} and use that instead.
   * 
   * @param expr1
   *          a side-effect-free expression with correct binding information
   *          that would be legal at the execution point indicated. It need not
   *          be an expression in context.
   * @param expr2
   *          same as expr1
   * @param before
   *          indicates the execution point: just before evaluating this
   *          expression. <b>NB: we could instead write an interface using a
   *          ControlNode</b>
   * @param constructorContext 
   *          The ConstructorDeclaration of the constructor currently being
   *          analyzed, or <code>null</code> if no constructor is currently
   *          being analyzed.
   */
  public boolean mayAlias(
      IRNode expr1, IRNode expr2, IRNode before, IRNode constructorContext);

  /**
   * As above, except that null is permitted (if both are null).
   */
  public boolean mustAlias(
      IRNode expr1, IRNode expr2, IRNode before, IRNode constructorContext);
}
